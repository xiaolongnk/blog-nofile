{"meta":{"title":"faith","subtitle":"leetcode学习笔记","description":"技术笔记，leetcode学习","author":"faith","url":"https://blog.nofile.cc"},"pages":[{"title":"About","date":"2016-08-15T03:59:07.000Z","updated":"2016-08-23T12:47:04.000Z","comments":true,"path":"about/index.html","permalink":"https://blog.nofile.cc/about/index.html","excerpt":"","text":"经历2014年毕业,在美丽说,一直在HIGO这个部门，后面HIGO独立，随HIGO一起到新HIGO。 本科期间，喜欢打魔兽， 经常逃课去打游戏，学习成绩一般，能勉强过关的那种。 大二接触linux，之后就再也没有丢开过，花了很多时间去折腾。从桌面开始，从fedora, 到ubuntu，到arch， 再到ubuntu。在这方面花了不少时间。 觉着linux的命令行才是真正的命令行，linux桌面才是真正的桌面，虽然很不稳定，经常 崩溃又从头再来，并 且很容易出各种奇怪的问题，但当时觉着也没什么，遇到什么问题，就 去找那个问题，知道那个问题解决。比如， 有时候我折腾了一晚上，就是为了让我的 linux系统可以识别我的U盘。经常更新下显卡驱动，就搞得进不去桌面系 统，当时不太会，干脆 重装，于是又来一遍。总之，各种各样的问题，花了好多时间，但那时候的我，好像并不觉 得烦， 一遍一遍得重复，似乎还有不少乐趣。 一遍遍的重复，对linux也慢慢了解了，重装系统的次数也越来越少。意识到和系统折腾其实也意义不大。 于是将更多的精力放在了写cpp上。初次见面，就是从写cpp开始的。发现写一个cpp竟然不用建工程。写一个 文件就可以了。和windows上vc6.0臃肿工程相比，在linux上竟然如此简洁，给我的那种惊喜，在哪个瞬间就 将我的兴趣俘虏了。之后，写cpp基本就在linux上了。 大学期间的算法和数据结构，基本都是在linux写的。 大四的实习，宣布着我程序员职业生涯的开始。 刚开始的工作，就给我分到了后端组。发现学校里的学习还是帮了我不少。 短暂的实习结束，从天津来到北京，进 入HIGO。同样是做后端，除了没怎么用过PHP，但对服务器和mysql这些 东西我基本都是熟悉的，所以进入状态也很快， 大概过了一周，我就可以熟练的写业务代码了。 在框架中编写代码，有一个缺点就是大部分代码都是模仿，所以并不 难。也没有什么挑战。 后面，需要做运营后台。和接口不同的是，这里要求界面，需要用web前端相关的。被迫要写一 些前端页面相关 的东西，刚开始做的那段时间，有一些界面，确实是不小的挑战，然后就是各种补，各种查，各种加班， 磕磕绊 绊搞出来的东西，一来长得其丑无比，二来烂的就像一坨..，三来写法落后的一逼，但是那时候我们团队没有人 擅长啊，我做出来的东西，我也觉着不太行，就勉强可以用, 当时大家的心思都在集中在客户端，后台的东西， 差不多 能用就可以了,大家也表示可以理解。 后面，有反馈，说整个页面刷新极大的影响运营效率，我才学会了ajax局部更新数 据，将一些要紧的地方更新了下。 慢慢的，我也跟着了解着，学习着前端。 几乎同时，我还负责了我们推送系统的构建。当时，邻居团队的项目已经有了，直接送给了我们，因为是python做的。 我之前懂一点，于是这个项目就给我了。但其实我的当时的python水平就比helloworld水平高一点呀。但我还是很自信 的接过 来了，没关系，不会可以学吗。代码都有了，看不懂查查不就懂了。 就这样，我接手了我们的push系统。 这个项目，我一直维护到今年3月份。期间除了不少问题。主要我们的APP内有聊天系统。一方面是推送系统要和聊天系统 对接，他们之间有的较多的环节,这些环节的设计上有一些误差。另一方面，大概是因为我写代码的能力不够，当时还没 有能力构建一个健壮的应用，这应该也是主要原因吧。我的推送程序经常跑着跑着自己就挂了。不过迭代了几个版本之后， 也基本趋于稳定了。 其他的时间，几乎就一直是客户端发版，写一些临时的为大促准备的接口,和修bug。其实技术方面的挑战，真没什么。最大 的挑战我觉着就是事情太多，虽然都没什么技术含量，但是事情多呀，多到让你没有周末，周末在家里也不能安宁，一会又 问题，在群里@你，你就不能不看。那时候的周末，应该只比工作日好一点，好的地方就是可以在家办公。 就这样过了大概2年。7月中旬，决定辞职。2016年8月10号，离职。 感悟最近面试，有一个感觉就是，工作了2年，其实并不一直都是成长的。前面1年感觉还好，但是第二年就很马虎了。在面试的时候，发现好多知识都很零散，没有系统，没有一个纲领，所以后面一年中，自己出了问题，自己也不怎么感觉得到，日子就是在划水。 受此启发，前连天整理了下自己的知识体系(图一) 它并不表明我掌握了面列举的所有，但我学习的时间，基本上都是和他们有关，从另一方面来看，这也是以后发展的一个方向。不管做什么样的业务，在什么样的公司，希望自己不再迷芒,实在不知道该干什么时，可以从这个图上一点点来突破。"},{"title":"tags","date":"2016-08-17T06:15:40.000Z","updated":"2016-08-17T06:17:31.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.nofile.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"382. Linked List Random Node","slug":"ag-382","date":"2016-08-20T11:07:00.000Z","updated":"2016-08-20T11:31:26.000Z","comments":true,"path":"posts/leetcode/2016/08/20/ag-382.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/20/ag-382.html","excerpt":"","text":"382. Linked List Random NodeGiven a singly linked list, return a random node&apos;s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 分析这个题目的做法其实很简单。最开始先选择第一个元素，然后一直往后那，到第k个元素，以1/k的概率用这个元素替换已经选中的元素。可以证明每个元素被选中的概率都是1/n。算法最核心就是以1/k的概率替换选中的元素。这个可以利用rand函数就可以实现。因为cnt从0开始，所以拿参0来做参考值。下面是证明过程。第k个元素最终被选择的概率=第k个元素被选择*并且在后面的选择过程中没有被替换的概率=1/k*(1-1/(k+1))*(1-1/(k+2))...*(1-(1/n))=1/n。这就可以表明，算法中的每个元素被选择的概率都是1/n 看了下同类的题解，都说到了这个蓄水池抽样,这篇文章写的不错，里面有详细的分析和证明，大家可以参考下，我就不再这里重复了，最主要的是自己能够计算证明一下概率的计算。 代码import randomclass Solution(object): def __init__(self, head): self.head = head def getRandom(self): tmp = self.head cnt = 0 ans = None while tmp: if random.randint(0,cnt) == 0: ans = tmp tmp = tmp.next cnt += 1 return ans.val class ListNode(object): def __init__(self , val): self.val = val self.next = Nonedef genList(head): prev = head for i in range(0,5): tmp = ListNode(i) tmp.val = i tmp.next = None if i == 0: head = tmp prev = tmp else: prev.next = tmp prev = tmp return headdef printList(head): tmp = head while tmp: print tmp.val, tmp = tmp.next passif __name__=='__main__': head = ListNode(-1) nh = genList(head) mapp = dict() for i in range(0,5): mapp[i] = 0 obj = Solution(nh) for i in range(0,100000): val = obj.getRandom() mapp[val]+=1 for k in mapp: print mapp[k],str(float(mapp[k])/100000 * 100)+\"%\"","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"random","slug":"random","permalink":"https://blog.nofile.cc/tags/random/"},{"name":"概率","slug":"概率","permalink":"https://blog.nofile.cc/tags/概率/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"Longest Palindromic Substring","slug":"ag-05","date":"2016-08-20T11:06:00.000Z","updated":"2016-08-20T11:31:21.000Z","comments":true,"path":"posts/leetcode/2016/08/20/ag-05.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/20/ag-05.html","excerpt":"","text":"Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. 分析看到了将先将原字符串处理成带#的方式，觉着这样处理方便一些。这样处理之后，最长的回文子串一定是关于#中心对称的。所以在我们的算法中，只要对每一个字符j，判断它两边的最长对称串就可以了。整体的复杂度大概是o(n2)。注意对数组越界的处理。这个思路，用python实现了，无奈会超时，该用c实现就可以了。但是刚开始总有几个case和我本机测试不一样。以为oj出问题了，后面再本地多高了几组样例测试，发现本地其实也有问题。后面检查，是我的那个临时变量没有初始化。初始化了之后，ac，并且速度也还可以。作为参考，2份代码都贴了过来，我先写了python版本的，后面发现超时，就将python的翻译成了c版本的。除了char数组变量初始化的坑，其他的基本还好。以后写c代码，一定记得变量初始化。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char* longestPalindrome(char* s) &#123; char ts[2005]; memset(ts,0,sizeof(ts)); ts[0] = '#'; int cnt = 1; for(int i = 0; i &lt; strlen(s); i++)&#123; ts[cnt++] = s[i]; ts[cnt++] = '#'; &#125; int lents = strlen(ts); int max = 1; int pos = 0; for(int i = 0; i &lt;lents; i++)&#123; int currentMax = 1; for(int j = 0 ; j &lt; i ; j++)&#123; int l = i - j - 1; int r = i + j + 1; if(l &lt; 0 || r &gt;= lents)&#123; break; &#125; if( ts[l] == ts[r])&#123; currentMax+=2; &#125;else &#123; break; &#125; &#125; currentMax = (currentMax - 1) / 2; if (currentMax &gt;= max)&#123; max = currentMax; pos = i; &#125; &#125; s = (char *)malloc(2005*sizeof(char)); memset(s , 0 ,sizeof(s)); cnt = 0; for(int i = pos - max + 1; i&lt;pos + max ; i++)&#123; if(ts[i]!='#') s[cnt++] = ts[i]; &#125; s[cnt]='\\0'; return s;&#125;int main()&#123; char str[1000]; while(scanf(\"%s\",str)!=EOF)&#123; char * ans = longestPalindrome(str); printf(\"%s\\n\",ans); &#125; return 0; &#125; class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" ns = \"#\"+\"#\".join(list(s))+\"#\" max = 1 pos = 0 mlen = len(ns) for i in range(0,mlen): currentMax = 1; for j in range(0,i): l = i - j - 1 r = i + 1 + j if l &lt; 0 or r &gt;= mlen: break; if ns[l] == ns[r]: currentMax+=2 else: break; currentMax = (currentMax - 1) /2 if currentMax &gt;= max: max = currentMax pos = i return \"\".join(ns[pos - max: pos + max + 1].split(\"#\")) if __name__=='__main__': ns = Solution() st = \"jglknendplocymmvwtoxvebkekzfdhykknufqdkntnqvgfbahsljkobhbxkvyictzkqjqydczuxjkgecdyhixdttxfqmgksrkyvopwprsgoszftuhawflzjyuyrujrxluhzjvbflxgcovilthvuihzttzithnsqbdxtafxrfrblulsakrahulwthhbjcslceewxfxtavljpimaqqlcbrdgtgjryjytgxljxtravwdlnrrauxplempnbfeusgtqzjtzshwieutxdytlrrqvyemlyzolhbkzhyfyttevqnfvmpqjngcnazmaagwihxrhmcibyfkccyrqwnzlzqeuenhwlzhbxqxerfifzncimwqsfatudjihtumrtjtggzleovihifxufvwqeimbxvzlxwcsknksogsbwwdlwulnetdysvsfkonggeedtshxqkgbhoscjgpiel\" print ns.longestPalindrome(st)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://blog.nofile.cc/tags/字符串/"},{"name":"算法","slug":"算法","permalink":"https://blog.nofile.cc/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"Expression Add Operators","slug":"ag-282","date":"2016-08-20T11:06:00.000Z","updated":"2016-08-20T11:31:25.000Z","comments":true,"path":"posts/leetcode/2016/08/20/ag-282.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/20/ag-282.html","excerpt":"","text":"282. Expression Add OperatorsGiven a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Examples: &quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;] &quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;] &quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;] &quot;3456237490&quot;, 9191 -&gt; [] 分析题目要求找到所有的计算方案。是一个明显的dfs问题。关键是想清楚dfs的方式。dfs的参数大概是这几个。要记录答案retList ，输入参数num，当前的target，当前搜索到字符串内的位置pos，当前的搜索路径path，当前的数字值current，前面的数字值prev。还要注意防止00这样的数字出现，所以在搜索是要对00这样的case进行下清理。 代码class Solution(object): def addOperators(self, num, target): \"\"\" :type num: str :type target: int :rtype: List[str] \"\"\" ans = [] self.solve( num , target , ans , 0 ,\"\" ,0 ,0) return ans def solve(self , num , target , retList , pos , path , current , prev ): if len(num) == pos: if current == target: retList.append(path) return for i in range(pos , len(num)): if i != pos and num[pos] == '0': break; curstr = num[pos:i+1] currentval = int(curstr) if pos == 0: self.solve(num , target , retList , i+1 , path + curstr , current + currentval , currentval) else: self.solve(num , target , retList , i+1 , path + '+' + curstr , current + currentval , currentval) self.solve(num , target , retList , i+1 , path + '-' + curstr , current - currentval , -currentval) self.solve(num , target , retList , i+1 , path + '*' + curstr , current - prev + prev * currentval , prev * currentval)if __name__=='__main__': sn = Solution() num = \"105\" target = 5 print sn.addOperators(num , target)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"HTTPS Your site","slug":"note-https","date":"2016-08-19T08:54:00.000Z","updated":"2016-08-23T14:07:23.000Z","comments":true,"path":"posts/web/2016/08/19/note-https.html","link":"","permalink":"https://blog.nofile.cc/posts/web/2016/08/19/note-https.html","excerpt":"","text":"让NGINX支持SSL需要编译时支持ssl，可以sbin/nginx -V 来查看confiture参数，如果当时没有支持，那么需要重新编译安装。 编译参数前面已经有一篇文章了。nginx编译参数,也不用全加，用--with-http_ssl_module 就可以了。 生成证书主要参考这个letsencrypty，可以生成免费证书。 生成方式也很简单，读上面的文章基本就能明白。ubuntu+nginx. 大致步骤如下： wget https://dl.eff.org/certbot-autochmod a+x certbot-auto./certbot-auto./path/to/certbot-auto certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is 执行完之后系统中会生成这些文件。 This command will obtain a single cert for example.com, www.example.com, thing.is, and m.thing.is; it will place files below /var/www/example to prove control of the first two domains, and under /var/www/thing for the second pair. Automating renewal上面生成的证书，有效期好像是1个月，所以需要到期自己重新renewal一下。方法如下： ./path/to/certbot-auto renew --dry-run./path/to/certbot-auto renew --quiet --no-self-upgrade 配置NGINX配置就不多说了.首先需要配置2个server，监听2个端口。这样可以强制将80端口的请求重定向至443端口。https本身监听的是443端口。最主要的是ssl中间那3行。将步骤2中生成的对应key写在nginx的配置文件里。注意改成你的具体路径。 server &#123; listen 443; server_name blog.nofile.cc; ssl on; ssl_certificate /xxxx/letsencrypt/live/yoursite/fullchain.pem; ssl_certificate_key /xxxx/letsencrypt/live/yoursite/privkey.pem; location / &#123; #这个地方指定被访问的文件夹位置 root /your/webroot/; index index.html; &#125;&#125;server &#123; listen 80; server_name blog.nofile.cc; return 301 https://blog.nofile.cc$request_uri; &#125; 配置好之后，重启nginx，应该就可以看到绿色的锁了。","categories":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}],"tags":[{"name":"https","slug":"https","permalink":"https://blog.nofile.cc/tags/https/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}]},{"title":"String to Integer (atoi)","slug":"ag-08","date":"2016-08-19T03:27:00.000Z","updated":"2016-08-20T11:31:22.000Z","comments":true,"path":"posts/leetcode/2016/08/19/ag-08.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/19/ag-08.html","excerpt":"","text":"String to Integer (atoi)implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析主要还是读题，其实题目还是挺不好读的，有好多细节，读不出来就会wa掉。因为计算过程中32int会溢出，所以结果返回用了long long。不知道用int是不是也可以实现。如果很在意时间的话，题目中应该可以看出，可能包含大量无效字符的case，所以直接忽略这类case，应该可以节省不少时间。 代码#include &lt;stdio.h&gt;int myAtoi(char* str) &#123;#define M_MAX_INT 2147483648#define N_MAX_INT -2147483648 if(str == NULL) return 0; int cnt = 0; int positive_flag = 1; long long ans = 0; while(*str != '\\0')&#123; if(*str == ' ')&#123; if(cnt) break; str++; continue; &#125;else if(*str &gt;= '0' &amp;&amp; *str &lt;='9')&#123; ans = ans * 10 + (*str - '0'); if(ans &gt;= M_MAX_INT ) &#123; if(positive_flag)&#123; ans = 2147483647; &#125;else &#123; ans = N_MAX_INT; &#125; return ans; &#125; cnt++; &#125; else if(*str == '-')&#123; if(cnt) break; positive_flag = 0; cnt++; &#125;else if(*str == '+')&#123; if(cnt) break; cnt++; &#125;else &#123; break; &#125; str++; &#125; if(positive_flag) return ans; else return -1*ans;&#125;int main()&#123; char str[100] =\"\"; while(gets(str))&#123; printf(\"input is: %s\\n\",str); int ans = myAtoi(str); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"atoi","slug":"atoi","permalink":"https://blog.nofile.cc/tags/atoi/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"leetcode LRU Cache","slug":"ag-146","date":"2016-08-18T15:29:00.000Z","updated":"2016-08-20T11:31:24.000Z","comments":true,"path":"posts/leetcode/2016/08/18/ag-146.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/18/ag-146.html","excerpt":"","text":"LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析读完题目，其实最核心的部分就是维护一个LRU的顺序，能够在需要淘汰数据的时候以o(1)的算法选出需要淘汰的节点。Python中有有序字典这种数据结构。这种字典可以将字典中的所有(k,v)按照插入顺序来保存。新插入的在后面。并且还提供了popitem方法。正好符合这个题目的要求。popitem(last=True|False),last = False 表示按照FIFO进行pop，True表示按照LIFO进行淘汰。注意边界。插入和访问都需要先将元素从这个OrderedDict中删除，以维护LRU所需要的顺序。 如果没有这种结构的话，可以自己实现一个双向链表来解决这个问题。这样链表结构的调整比较容易，如果是数组的话，将一个元素放在最前面，是要调整整个数组的顺序的，成本太高，这种情况，链表就很有优势,这就是用链表的最重要的原因吧。 代码import collectionsclass LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self.capacity = capacity self.ldict = collections.OrderedDict() def get(self, key): \"\"\" :rtype: int \"\"\" try: value = self.ldict[key] del self.ldict[key] self.ldict[key] = value return value except: return -1 def set(self, key, value): \"\"\" :type key: int :type value: int :rtype: nothing \"\"\" print self.capacity print self.ldict try: del self.ldict[key] self.ldict[key] = value except: if len(self.ldict) == self.capacity: self.ldict.popitem(last=False) self.ldict[key] = value def mprint(self): print self.ldictif __name__=='__main__': lru = LRUCache(3) lru.set(1,1) lru.set(2,2) lru.set(3,3) lru.set(4,4) lru.set(5,5) lru.set(3,3) lru.set(6,6) lru.mprint() pass","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.nofile.cc/tags/算法/"},{"name":"LRU","slug":"LRU","permalink":"https://blog.nofile.cc/tags/LRU/"},{"name":"有序字典","slug":"有序字典","permalink":"https://blog.nofile.cc/tags/有序字典/"},{"name":"OrderedDict","slug":"OrderedDict","permalink":"https://blog.nofile.cc/tags/OrderedDict/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"leetcode Mini Parser","slug":"ag-385","date":"2016-08-18T15:03:00.000Z","updated":"2016-08-20T11:31:28.000Z","comments":true,"path":"posts/leetcode/2016/08/18/ag-385.html","link":"","permalink":"https://blog.nofile.cc/posts/leetcode/2016/08/18/ag-385.html","excerpt":"","text":"Mini ParserGiven a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,’,’ , ].Example 1: Given s = “324”, You should return a NestedInteger object which contains a single integer 324.Example 2: Given s = “[123,[456,[789]]]”, Return a NestedInteger object containing a nested list with 2 elements: An integer containing value 123. A nested list containing two elements: An integer containing value 456. A nested list with one element: An integer containing value 789. 分析应该是一个字符串处理的问题。对特殊字符进行处理，处理事件主要由[,]来触发。o(n)算法。需要想清楚对每一个字符的处理方式。NestedInteger的维护，会使用到栈这种结构，在Python里面，list可以当作栈来使用。这个题目的边界条件，主要是[]里面可能是空的。整个过程有一点小复杂，主要还是靠自己思考，脑筋动起来吧。示例代码中的NestedInteger的class的方法是我自己加的，为了测试代码，测试语法问题。 代码class NestedInteger(object): def __init__(self,elem=None): pass def add(self , a): passclass Solution(object): def deserialize(self, s): \"\"\" :type s: str :rtype: NestedInteger \"\"\" lst = [] last_ic_ix = 0 if s[0] != '[': return NestedInteger(int(s)) for i in range(0,len(s)): if s[i] == '[': ns = NestedInteger() lst.append(ns) last_ic_ix = i elif s[i] == ',' or s[i] == ']': ss = s[last_ic_ix+1:i] if ss != '': tmp = int(ss) lst[len(lst)-1].add(NestedInteger(tmp)) last_ic_ix = i if s[i] == ']': top = lst.pop() if len(lst) == 0: return top lst[len(lst)-1].add(top) return Falseif __name__=='__main__': ns = Solution() print ns.deserialize(\"[123,3,[32,2,[33,24],3]]\");","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.nofile.cc/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"stack","slug":"stack","permalink":"https://blog.nofile.cc/tags/stack/"},{"name":"python","slug":"python","permalink":"https://blog.nofile.cc/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.nofile.cc/tags/数据结构/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/categories/leetcode/"}]},{"title":"Mysql笔记","slug":"note-mysql","date":"2016-08-17T10:24:30.000Z","updated":"2016-08-17T10:24:30.000Z","comments":true,"path":"posts/存储/2016/08/17/note-mysql.html","link":"","permalink":"https://blog.nofile.cc/posts/存储/2016/08/17/note-mysql.html","excerpt":"","text":"mysql 性能测试工具.Mysql 自带的性能测试工具. Mysql 索引Mysql 索引 Mysql 复合索引 http://tech.meituan.com/mysql-index.html现在只会创建单索引,但是很多情况下,复合索引更有效.一个表只能使用一个索引,如果单键索引和复合索引都会生效,那么mysql会选择哪个索引.mysql 索引的最左选择的原则. 有些情况下,优化的作用是很有限的,最好还是不要写太复杂的sql.但是有一个情景,就是需要更具字表的条件去筛选结果,做分页,这种情况如何处理.可以内存排序.让排序在mysql中排序比较困难.那么这个分页逻辑如何处理. Mysql join 之后的索引使用情况是怎么样的. order by 的字段是否有必要增加一个索引,如果有必要,是不是所有需要排序的字段都需要增加上索引. 索引是在数据库表或者视图上创建的对象，目的是为了加快对表或视图的查询的速度。按照存储方式分为：聚集与非聚集索引和B树B+树的关系还是差别挺密切的,需要认真理解一下B树和B+树. MySQL如何利用索引优化ORDER BY排序语句MySQL索引通常是被用于提高WHERE条件的数据行匹配或者执行联结操作时匹配其它表的数据行的搜索速度。MySQL也能利用索引来快速地执行ORDER BY和GROUP BY语句的排序和分组操作。 mysql一次查询只能使用一个索引。如果要对多个字段使用索引，建立复合索引。 create table blog_pool(id bigint(20) not null auto_increment,account_id bigint(20) not null default 0 comment &apos;user id&apos;,blog_id bigint(20) not null default 0 comment &apos;blog_id&apos;,content varchar(1024) not null default 0 comment &apos;blog内容&apos;,status tinyint(2) not null default 1 comment &apos;1: 正常 -1: 删除&apos;,primary key (id),index list_blog_index (account_id,status),index single_index (account_id))engine = Innodb , charset=utf8 , auto_increment=1;insert into blog_pool (account_id, blog_id, content) values (923232323, ); explain 显示mysql如何处理select语句以及连接表,可以帮助写出更好的查询语句和建立更好的索引. select typesimple 表示是简单的select ,primary 表示最外面的select .union 表示union语句的第二个. rows 表示mysql执行查询的行数,数值越大说明效果越不好,说明没有用好索引. using where ,要想使查询尽可能的快, 应尽可能得找出 using filesort , using temporary 的extra的值.我觉这在业务重没有必要禁止连表查询，在不会带来什么压力的情况下，并没有什么必要。如果两个表，都比较简单，连表也没什么不可以。什么事情都应该分开来看待，没有什么是绝对的。 select 按指定顺序排select * from xxx where id in (3,1,5) order by find_in_set(id,&apos;3,1,5&apos;) order by substring_index和order by find_in_set都可以 mysql 中创建用户。CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 如果是当前登陆用户 more detailed info see this link. http://www.jb51.net/article/31850.htm mysql 中的数据类型tinyint 1 字节 -128 ~ 128 smallint 2 字节 -32768 ~ 32767 mediumint 3字节 int 4字节 int(11) bigint 8字节 unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615 Mysql decimal对于精度比较高的东西，比如money，我会用decimal类型，不会考虑float,double,因为他们容易产生误差，numeric和decimal同义，numeric将自动转成decimal。DECIMAL从MySQL 5.1引入，列的声明语法是DECIMAL(M,D)。在MySQL 5.1中，参量的取值范围如下：·M是数字的最大数（精度）。其范围为1～65（在较旧的MySQL版本中，允许的范围是1～254），M 的默认值是10。·D是小数点右侧数字的数目（标度）。其范围是0～30，但不得超过M。说明：float占4个字节，double占8个字节，decimail(M,D)占M+2个字节。 关于decimal范围的判断，下面这是一个不错的解释。 Although the answers above seems correct, just a simple explanation to give you an idea of how it works. Suppose that your column is set to be DECIMAL(13,4). This means that the column will have a total size of 13 digits where 4 of these will be used for precision representation. So, in summary, for that column you would have a max value of: 999999999,9999 引申 为什么floa 和 double 会丢失精度。1 字节 = 8 bit。 int 一般认为是32位。最长是10位。float 为4byte。double 为8btye。IEEE 754 标准，数的存法。 datetime 和 timestamp 的区别。ctime datetime =&gt; now() 4字节 mtime timestamp ==&gt; CURRENT_TIMESTAMP 8字节 1970 ~ 2037 MYsql 几个常用关键字in ，not in，exists 和 not exists 关键字。 Mysql 表间元素复制create table newtable select * from oldtable;INSERT INTO newTable SELECT * FROM oldTable;INSERT INTO newTable (col1,col2,…….) SELECT col1,col2,…… FROM old_table insert into on duplicateinsert into myblog (id,title,ctime) values(123,'hello',now()) on duplicate key update title=values(title),ctime=values(ctime);//将 blog_bak 表中的所有数据导入到myblog 中，表 blog 和 blog_bak 应该有同样的表结构insert into myblog( blog,ctime) select * from blog_bak; Mysql连表update这样可以将 table_b 的 状态同步到 table_a, 本质上和 多表查询是类似的。 update table_a a , table_b b set a.shop_status = b.group_status where a.shop_id = b.shop_id; Mysql 索引操作 mysqldump 数据导出和数据恢复create index index_name on table_name (column_list);alter table table_name add index index_name (column_list);对应的，删除索引。drop index index_name on table;alter table table_name drop index index_name;清空表中的数据，包括 auto_increment 的字段都会被重置。truncate table_name;mysqldump -h localhost -ppasswd -uroot -d database &gt; dump.sql ; // 只导出数据库的结构mysqldump -h localhost -ppasswd -uroot database &gt; dump.sql ; // 导出数据库的结构和所有的数据mysqldump -h localhost -ppasswd -uroot -d database tablename &gt; dump.sql ; // 只导出表结构mysqldump -h localhost -ppasswd -uroot database tablename &gt; dump.sql ; // 导出表结构和表中的数据mysql -u root -p yourpasswd -h localhost yourdb &lt; dump.sql // 将dump.sql 导出入到你的数据库 mysql 中的test 表的使用方法。如果你在数据表中没有数据的到处权限，但是一般的数据库中，test库中的权限你都是有的，所有可以将需要的数据先导入到test中的临时表中，然后再从临时表中导出去。这样可以绕开权限控制，到处你需要的数据。sql如下create table xxx as select * from you_target_table where xxx=xxx;这样 一张 test 中的临时表就创建好了，你可以用mysqldump将这个表中的数据导出去。 mysql时间处理函数select date_format(now(),\"%Y-%m-%d %H:%i:%s\") now;select date_sub(now(), interval 10 day) as yesterday; // 请不要吧 day 写成 days ，month , hour 同理。group by 多个字段 从 col_a -&gt; col_b -&gt; col_c 优先级依次降低。select * from test_table where status = 1 order by col_a desc, col_b desc, col_c asc limit 100;set @a = 100;select @a:=300; #可以通过 select 给变量赋值,这个变量只在这个链接周期中有效。 mysql 存储过程下面是一个简单的存储过程的例子。 delimiter $ # 因为 mysql 默认的 终止符是; 而这个正好是存储过程的语法，所以在编写存储过程之前，先将 delimiter 改成 $create procedure p() # 创建存储过程beginselect * from ttt;end;$delimiter ; # 将 delimiter 改成默认的; 这样符合我们的习惯call p(); # 调用这个存储过程 mysql ifif(tb2.shop_click is null, 0,tb2.shop_click)","categories":[{"name":"存储","slug":"存储","permalink":"https://blog.nofile.cc/categories/存储/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://blog.nofile.cc/tags/Mysql/"}],"keywords":[{"name":"存储","slug":"存储","permalink":"https://blog.nofile.cc/categories/存储/"}]},{"title":"前端笔记","slug":"note-web","date":"2016-08-17T09:55:18.000Z","updated":"2016-08-17T09:55:18.000Z","comments":true,"path":"posts/前端/2016/08/17/note-web.html","link":"","permalink":"https://blog.nofile.cc/posts/前端/2016/08/17/note-web.html","excerpt":"","text":"marginmargin: 的4个参数。up ,right, down , left;如果只有一个参数，那么表示4个都是n px。可以是1–4个参数。 some input typeradio, checkbox , button, 他们都有对应的时间，可以在里面添加对应的 函数。可以带参数的。checkbox 也可以写成数组。name=’chk[]’ $_REQUEST [‘chk’] 取值的方式是这样的。 fontawesome学习两个前端页面会使用到的js. https://www.woothemes.com/flexslider/ 这个是用来做轮播图的js。http://fontawesome.dashgame.com/这个是用来给页面中显示一些字体用的。还有一些常用的图标，用法也很简单， ####304 错误. 强制不从本地设备读取内容. &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt; Node基础http://npm.taobao.org/首先是npm， node package manager, 这个还相对好理解。可以用淘宝的镜像，速度会快一点。换一个淘宝镜像。例外是nvm，这个是node version manager。node 的版本太多了，所以也有了一个manager。nvm 可以选择安装 node 的版本，也很方便。nvm可以从这里下载。https://raw.githubusercontent.com/creationix/nvm/v0.4.0/install.sh 在一个node的项目里，可以通过cnpm install来安装项目依赖。这里推荐一个node的应用[hexo]https://hexo.io/.我的blog就是基于这个做的。 在lavarel中使用静态图片。q1: 在页面中中使让一段字体在一个div中垂直居中？http://stackoverflow.com/questions/79461/vertical-alignment-of-elements-in-a-div 几个常用的 搜索引擎 搜索引擎 地址 百度 http://zhanzhang.baidu.com/sitesubmit/index 谷歌 http://www.sogou.com/feedback/urlfeedback.php 谷歌 http://www.google.com/intl/zh-CN/add_url.html","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.nofile.cc/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.nofile.cc/tags/html/"},{"name":"css","slug":"css","permalink":"https://blog.nofile.cc/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://blog.nofile.cc/categories/前端/"}]},{"title":"Linux VPN 配置","slug":"note-vpn","date":"2016-08-17T09:55:17.000Z","updated":"2016-08-17T09:55:17.000Z","comments":true,"path":"posts/VPN/2016/08/17/note-vpn.html","link":"","permalink":"https://blog.nofile.cc/posts/VPN/2016/08/17/note-vpn.html","excerpt":"","text":"ubuntu14.04 安装vpn这个是最正确的教程，没有之一。http://mad-scientist.us/juniper.html下面是一个简单的总结 sudo apt-get install libstdc++6:i386 lib32z1 lib32ncurses5 libxext6:i386 libxrender1:i386 libxtst6:i386 libxi6:i386sudo apt-get install openjdk-7-jre icedtea-7-plugin openjdk-7-jre:i386sudo apt-get install icedtea-pluginsudo apt-get install libc6-i386 lib32nss-mdnssudo apt-get install libgtk2-perl libwww-perlwget -q -O /tmp/msjnc https://raw.github.com/madscientist/msjnc/master/msjncchmod 755 /tmp/msjncsudo cp /tmp/msjnc /usr/bin http://www.scc.kit.edu/scc/net/juniper-vpn/linux/ 还可以参考这个帖子。需要得到realm这个东西，这个东西，去你公司的vpn网站爬一下就可以了。搜索一下realm这个字，就可以看到这个内容的值。最终推荐使用哪个客户端,比mac的客户端还好用。不过如果没有特别的爱好，还是用mac吧,折腾起来，还是有点麻烦的。","categories":[{"name":"VPN","slug":"VPN","permalink":"https://blog.nofile.cc/categories/VPN/"}],"tags":[{"name":"VPN MSJNC","slug":"VPN-MSJNC","permalink":"https://blog.nofile.cc/tags/VPN-MSJNC/"}],"keywords":[{"name":"VPN","slug":"VPN","permalink":"https://blog.nofile.cc/categories/VPN/"}]},{"title":"vim 学习笔记","slug":"note-vim","date":"2016-08-17T09:55:16.000Z","updated":"2016-08-17T09:55:16.000Z","comments":true,"path":"posts/VIM/2016/08/17/note-vim.html","link":"","permalink":"https://blog.nofile.cc/posts/VIM/2016/08/17/note-vim.html","excerpt":"","text":"vim的几个常用的插件。 插件 说明 ctags tags 的标签 vim-ariline 彩色 的状态栏 nerdtree 一个文件管理器 gittur git集成插件,可以显示修改了的内容 bundle 插件管理 vim-markdown 支持markdown的语法 VIMSCRIPT下面是一些简单的vimscript内容。 vim 中定义变量要用let a=123 空格并不能影响效果，这一点和shell并不一样.echo a这样就可以看到效果。在 vimrc 中可以写简单函数，来做一些想做的事情，比如根据文件后缀，自动执行脚本程序。:echo % 这个是获得当前文件的全名，包括后缀的。:echo %&lt; 和下面的一行作用一样。:echo %:r 这个是获取当前文件的文件名，除去扩展后缀 插入模式下的 vim ， ctrl + j 可以将文本内容下移一行。ctrl + m 我也不知道具体是什么，我只是通过实验尝试出来的。 VIM 启动速度慢 slowstartvim –startuptime vim.log -c qsudo vim 启动速度超级慢。vim 启动速度变慢.在终端中可以这样启动 vim -X 这样是不需要和X挂上勾的,所以会变慢.修改了一下之后瞬间感觉电脑变快了.vimariline这个插件会明显增加启动时间，加之没什么用，后面就从我的vim插件里面去掉了。 sudo vim 启动速度超级慢调查之后，发现是我把系统的hosts文件删除了，touch了一个空文件。后面，总是提示unresolve host 的提示。在增加了我的hostname在host中之后，sudo vim 速度就快了。开来和这个也有关系。 vim 记录上次编辑位置。au BufReadPost * if line(&quot;&apos;\\&quot;&quot;) &gt; 0|if line(&quot;&apos;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &apos;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif vim 删除重复行sortg/^\\(.\\+\\)$\\n\\1/d vim 插入当前时间插入时间，这个应该说是很方便的，但是我并不懂这个命令是怎么实现的。在vimrc中加入这个map，在normal模式下，输入,dt就可以在当前位置插入时间了。 map ,dt a&lt;C-R&gt;=strftime(&apos;%Y-%m-%d %H:%M&apos;)&lt;CR&gt; vim find天刚学到的是 find 命令，这个是用来打开文件用的，可以智能补全。set path=/home/yourpath vim 导入其他文件内容将当前文件的部分内容导入到其他文件1,20 w&gt;&gt; /path/otherfile.txt1,20 w /path/otherfile.txt具体命令就是这样。 同样的，也可以将其他文件的内容读入到当前文件来。命令是这个r: /path/file.txt 同时，这个命令也可以将外部程序的输出读入到当前文件中。r !date这样也是可以插入时间的。将这个命令用map命令映射一下，就可以得到和那个实现的同样的功能了。 VIM和系统共享剪切板首先需要补充的一点是，+寄存器是只有vim-gtk 或者 vim-gnome 才会有的，不要只安装了vim，这是不够的啦，在安装的时候需要注意一下，不然是无法使用系统剪切板的啦。复制单个字符， nyl n 是数字，l和vim的方向键一样，表示向后，就是向后复制n个字符。同理，nyh 表示向前复制n个字符。这样就可以很自由的复制了。复制单词 ynw 其中n是数字，表示要复制的单词的个数。按行为单位复制：nyy 表示复制n 行，和上面的命令差不多。应该是向下取的。p 表示粘贴，注意小写，这个是代表粘贴在下面。P 也表示粘贴，这次是大写啊，这个是代表粘贴在前面。估计对于字符复制粘贴的内容也是同样的规则啊。“+y 表示复制到系统剪切板去。这个应该忘不了吧。 vim 有很多的粘贴板，这些东西的用处你自己应该可以理解，一般情况下，都是只用一个粘贴板的，但是粘贴板多一点也是没有坏处的啊。vim中的复制是用y来完成的，在这之前，你当然可以决定你的内容是存放在那个粘贴办中，你可以用reg来查看这些粘贴板中都存了什么内容，同时p是用来复制的，你也可以在复制之前决定你从哪个粘贴板中复制内容，例如”4p表示是从4好粘贴板中拿东西。如果4好粘贴板中有你存下的内容的话，那么他就可以复制出来了，结合上面的命令，你当然可以做成你想做的。复制到第n 个粘贴板的命令: 先选择要复制的内容，然后”ny 就可以将这些内容放到粘贴板了。然后在你想复制的地方”+p 就可以了。","categories":[{"name":"VIM","slug":"VIM","permalink":"https://blog.nofile.cc/categories/VIM/"}],"tags":[{"name":"VIM","slug":"VIM","permalink":"https://blog.nofile.cc/tags/VIM/"}],"keywords":[{"name":"VIM","slug":"VIM","permalink":"https://blog.nofile.cc/categories/VIM/"}]},{"title":"Ubuntu学习笔记","slug":"note-ubuntu","date":"2016-08-17T09:55:15.000Z","updated":"2016-08-17T09:55:15.000Z","comments":true,"path":"posts/Linux/2016/08/17/note-ubuntu.html","link":"","permalink":"https://blog.nofile.cc/posts/Linux/2016/08/17/note-ubuntu.html","excerpt":"","text":"制作 ubuntu 镜像sudo dd if=/home/your.iso of=/dev/sdb 安装 fcitx 搜狗输入法。 确保你的语言包是全的。 安装这个语言包。http://pinyin.sogou.com/linux/ 按照这个做 http://jingyan.baidu.com/article/adc815134f4b92f722bf7350.html 安装firefox 插件json, vimperator, firebug. 安装 nginx ， php ， mysql ， php-redis 扩展。nginx http://nginx.org/en/download.htmlphp http://php.net/get/php-5.6.15.tar.gz/from/a/mirror php 编译参数. sudo apt-get install libcurl4-openssl-devsudo apt-get install libssl-devsudo apt-get install libxml2-dev./configure --prefix=/home/faith/blackh/server/php --with-config-file-path=/home/faith/blackh/server/php/etc --with-mysql=/usr/ --with-iconv-dir=/usr/ --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-fpm --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-zlib --enable-pdo --with-pdo-mysql --with-mysql=shared,mysqlnd 安装php-redis 扩展。http://pecl.php.net/package/redisphp nginx 配置,这些也很重要。 tmux vim slowstarttmux 中vim slow start 的原因,就是因为开了多个tmux,启动速度就变慢了.查看了slowlog,发现是因为xsmp消耗了大概1s的时间.只要保证一个tmux运行就可以了. grub customersudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get install grub-customizer 让你的ubuntu文件夹变成彩色的.可以添加下面的ppa,添加这个sudo add-apt-repository ppa:costales/folder-color然后安装下面这个 folder-color 就可以了.sudo apt-get install folder-color ubuntu安装更新版本的软件在linux中,我想升级gedit,比如说我的是 ubuntu14.04, 但是在 ubuntu15.10 里面,gedit 的版本是比我的新的.但是在14.04里面我确用不了最新的gedit .这个时候,我可以从官网下载最新的gedit ,安装,然而安装的时候会出现一些问题.这时候怎么办呢.可以这样. sudo apt-get build-deb geditsudo apt-get build-deb libreoffice5.0 然后执行安装命令就可以了.安装应该不会出错了.下面解释一下这个命令究竟是做什么的. ubuntu get source code如何获取ubuntu的源码你可以获取任何一个你所使用的源码包.这就是开源的系统.只要你的系统的源里有dep-src 这个选项,那么就可以随便获得系统源码.就像下面这样. deb-src http://archive.canonical.com/ubuntu trusty partnerdeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty universedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universedeb-src http://extras.ubuntu.com/ubuntu trusty maindeb-src http://security.ubuntu.com/ubuntu trusty-security main restricteddeb-src http://security.ubuntu.com/ubuntu trusty-security multiversedeb-src http://security.ubuntu.com/ubuntu trusty-security universe使用下面的命令.sudo apt-cache showsrc gedit #showsrc 可以用来查询有没有你需要的源码包sudo apt-cache source gedit #source 命令用来获取你需要的源码包 ubuntu自己编译出deb当然在这些工作之前,我们需要确保安装一些基本的工具.dpkg-dev 先安装这个. 在编译源码包之前,需要安装具有依赖关系的软件包,可以使用这个命令,就是上面的那个.build-dep 命令. sudo apt-get build-dep xxx#通过上面两个命令,就可以得到自己的源码包了.然后利用cd yoursrcsudo dpkg-buildpackage 这样就可以得到你的dep文件了.可以使用下面的命令来安装deb文件.sudo dpkg -i *.deb 有了上面的知识,你就可以利用自己的系统,学习各种工具的源码了,包括vim , emacs.加油吧.^_^ 关于ubuntu 的dash 残留应用的问题在你的本地文件里面. .local/share/applications/ 里面把对应的删除,重新登陆就可以看到你讨厌的那个东西不见了.下面是我的 ubuntu dash 中的eclipse的快捷方式.可以很明显的看到是我的路径出了问题. 我需要修改一下路径就可以了. ubuntu 安装中文字体sudo apt-get install mysql-workbenchsudo apt-get install ttf-wqy-microhei sudo apt-get install ttf-wqy-zenhei nmap 具体的参数还需要进一步阅读手册。nmap -PS 192.168.0.102 #扫描一个主机所有开启的端口。nmap -sP 192.168.0.* #扫描一个网段下的所有活动的主机。 Ubuntu create launcherubuntu launcher. alacarteubuntu 创建快捷方式．用这个软件．在mate桌面上安装创建自己的启动方式．要给我的zendstudio 创建．sudo apt-get install gnome-panel linux rm hidden filesrm -rf 是不会删除隐藏文件的.rm -rf .这个命令会过滤调. .. ,这两个目录是无法删除的. Ubuntu 关闭 crash reportubuntu 关闭没用的 crash report。sudo vim /etc/default/apport Ubuntu N卡驱动对硬件的了解是我的最大的弱点。电脑的什么显卡驱动啊，什么网卡驱动，我都没有搞清楚。 I installed latest nvidia drivers by this method: 幸好是可以上网，如果不能上网，我真是有点没招了。glxinfo | headhttp://askubuntu.com/questions/319671/how-to-change-the-graphics-card-driver-via-terminalubuntu-drivers devicesto get a list of your devices and identify the one you want. My output looked like this:ubuntu-drivers devices== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==modalias : pci:v000010DEd00000391sv00001462sd00000630bc03sc00i00vendor : NVIDIA Corporationmodel : G73 [GeForce 7600 GT]driver : nvidia-304 - distro non-free recommendeddriver : nvidia-173 - distro non-freedriver : xserver-xorg-video-nouveau - distro free builtindriver : nvidia-304-updates - distro non-freeI wanted nvidia-304 so I typed:apt-get install nvidia-304 Then I rebooted and confirmed using the desktop appliaction Additional Drivers that I was indeed using the driver I had chosen. 我遇到的最本质的问题是，我不会在命令行下安装显卡驱动，切换显卡驱动。所以导致各种问题。上面的命令正好是教会这个。 ubuntu重启gui执行完上面的安装命令，然后 startx sudo service start lightdm 就可以启动了图形界面了，回到原来的样子。 aglike ack but faster. lspci glxinfo | head 如果显卡驱动有问题，这个命令会不正常。正常的话，会列出来一些相关的东西。 modinfo系统默认安装的驱动是这个。xserver-xorg-video-intelmodprobe -r nouveau 用这个命令来卸载这个模块，从内核中卸载这个模块。 ubuntu enable sudo for work# provided their password# (Note that later entries override this, so you might need to move# it further down)%sudo ALL=(ALL) ALL then add the sudo group just like this;groupadd sudosudo usermod -aG sudo work http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html ubuntu firefox flash遇到的问题是 firefox has prevented the outdated flashplugin from xxx website.我从官网下载 tar.gz 之后，安装还是没有解决问题。貌似要用 apt-cache 来搜索才行，现在貌似好了，问题就是这样解决的。sudo apt-get install flashplugin-downloader貌似真得好了。 Linux 更新时间Linux 更新时间.主要的就是这个命令.ntpdate cn.pool.ntp.org好像 windows 时间 和 Linux 时间一定会又一个出问题.现在有点没有办法.将时间写入到 cmos 主要是系统时间写入 硬件时间 和 硬件时间写入系统的区别.sudo hwclock –systohcsudo hwclock –hctosys 允许程序没有sudo权限执行sudo chmod +s /usr/sbin/hddtemp这样就可以让 hddtemp 在没有 sudo 权限的情况下运行了。 xargsok, today I learned about xargs command. this solve the problem like this.rm -rf lsnow you can do like this;ls | xargs rm -rf","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.nofile.cc/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.nofile.cc/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://blog.nofile.cc/categories/Linux/"}]},{"title":"sphinx学习笔记","slug":"note-sphinx","date":"2016-08-17T09:55:14.000Z","updated":"2016-08-17T09:55:14.000Z","comments":true,"path":"posts/sphinx/2016/08/17/note-sphinx.html","link":"","permalink":"https://blog.nofile.cc/posts/sphinx/2016/08/17/note-sphinx.html","excerpt":"","text":"sphinx实践用shpinx实现一个搜索相关的小项目","categories":[{"name":"sphinx","slug":"sphinx","permalink":"https://blog.nofile.cc/categories/sphinx/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://blog.nofile.cc/tags/搜索/"}],"keywords":[{"name":"sphinx","slug":"sphinx","permalink":"https://blog.nofile.cc/categories/sphinx/"}]},{"title":"mac常用软件","slug":"note-software","date":"2016-08-17T09:55:12.000Z","updated":"2016-08-17T09:55:12.000Z","comments":true,"path":"posts/开发工具/2016/08/17/note-software.html","link":"","permalink":"https://blog.nofile.cc/posts/开发工具/2016/08/17/note-software.html","excerpt":"","text":"charles APP代理软件charles 破解。我的link。 http://pan.baidu.com/s/1i4UUbOh Dash非常便捷的API手册，方便查询。 PhpStormPHP 开发的好帮手，可以帮你避免一些低级错误。 WebStorm和Phpstorm是同一个公司开发的，使用上和PhpStorm 差不多,用于偏前端的开发工作场景。 ipythonPython 命令行工具，和Python不同的是，这个可以进行命令提示，方便初学者。 Postman管理接口，方便重用，经常和一堆接口打交道的话，这个会很方便。 以上貌似除了postman，其他的都是付费的。不过买起来确实很贵，但破解都 相对容易，需要的话，请自行百度，都很简单。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"},{"name":"工程效率","slug":"工程效率","permalink":"https://blog.nofile.cc/tags/工程效率/"}],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/categories/开发工具/"}]},{"title":"shell 学习笔记","slug":"note-shell","date":"2016-08-17T09:55:11.000Z","updated":"2016-08-17T09:55:11.000Z","comments":true,"path":"posts/shell/2016/08/17/note-shell.html","link":"","permalink":"https://blog.nofile.cc/posts/shell/2016/08/17/note-shell.html","excerpt":"","text":"awk simple awk skill is necessary. the follow command can be used to restart php-fpm in server. ps aux | grep ‘php-fpm’ | awk ‘{print $1}’ | xargs kill -USR2 -F option 是用来改变默认的分隔符的。awk -F ‘:’ ‘{print $3}’ awk 的 BEGIN 和 END 语句的功能。BEGIN 是最开始的部分执行的，然后AWK开始读取文件内容，进行处理。END 是最后面结束执行的. sed sed &apos;s/xx/ds/&apos; note[ ! -x result ] &amp;&amp; mkdir resultfor i in `ls *.grb`do out=`echo $i | sed &apos;s/GLDAS_NOAH10_M.A//&apos; | sed &apos;s/\\..*[[:graph:]]//&apos;` wgrib $i &gt; result/$out&quot;.out&quot;done d 表示是删除的意思。用新文件覆盖旧文件。sed ‘/vim/d’ ~/.bashrc &gt; ~/.bashrc刚才才发现原来 shell 的字符串判断相等是 = 左右两天加个空格就可以了。如果不加空格就是赋值。这种语法还是有点诡异的啊。并且现在很少写 if 这个东西了，自从我发现了 if 语句可以简写之后。字符串操作还是又必要掌握一下的。果然shell python 相比来说直截了当多了。正事因为 shell 在字符串处理上的缺陷，所以才有了sed这样的工具来补充吧。当然还有awk。 sedsed 用得最多的就是替换了。很多时候，grep就足够了。 sed -i “This command to use replace the input file”just a simple example.sed -i ‘s/–/-/‘ grep find shell重定向来自这个链接 http://www.cnblogs.com/yangyongzhi/p/3364939.html ./Test.py 1&gt;normal 2&gt;error 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3./Test.py 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 1&gt;normal 2&gt;error 可以通过这两个命令看出差别,其实就是从右向左执行的. 具体的执行过程是这样的,一个完整的shell指令的执行是从右往左的.先执行 1&gt;&amp;3 , 然后执行 2&gt;&amp;1 , 3&gt;&amp;2 git 跨源合并一个项目可以添加多个源,origin是默认的一个源.并且也可以跨源合并.这是比较高级的用法.如果要跨项目合并. git 跨项目合并. git remote add code “url”git push code master shell get your ipifconfig | grep -E -o &quot;inet ([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1ip a| grep -E -o &quot;inet addr:([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1 linux 下 ifconfig | grep ‘inet ‘ | awk ‘{split($2, ip_cntr, “:”); print ip_cntr[2];}’ tmux.conf想在tmux.conf中添加一些shell脚本,可以获取到我自己的IP地址.这样我在连接代理的时候,就不用是自己查了.我把自己的tmux的status line 搞成了1s刷新一次.用了这个命令. egrep grep -Efgrep grep -F 只支持简单的全部匹配,部支持正则匹配. nohup command &gt; out.txt 2&gt;&amp;1 &amp; 这样是将所有的输出,包括错误都重定向到out.txt中. grep 输出匹配内容的上下两行内容,输出上下文,记得这个参数.grep -C 2 ‘linux’是用nohup命令,完了这个命令就没有办法停止了,就会一直运行,除非用kill命令讲这些命令kill调. git push –forcegit remote add. 将一个远端的项目添加到新的分支上,然后可以合并。git remote add name git@gitlabserver.meiliworks.com:higo/api.git删除这个分支。git remote rm old_pandoragit 将某个分支强制覆盖。比如我想用newpush 的代码完全覆盖 master 的代码。可以这样做。git push origin newpush:master -f git remote add origin url #这样可以讲自己的git目录添加到远端仓库.很方便.同一个项目可以添加多个远端仓库,可以一起使用. shell functions函数的返回值,函数的参数.http://www.jb51.net/article/33895.htm这里看到了一些参考,主要是这两个参数, $@ 和 $* 是一样的,可以将函数的参数当做一个字符串.如果你仍然利用$1,$#,$0这些而参数,那么你可能得不到你想要的结果.并且,我在shell下添加了一些常用的颜色的变量,只要. ~/.colorful 就可以使用这些变量了.可以进行一些彩色的输出,是得程序更加明确.其他的就是对shell更加熟悉了,大小的比较,相等的比较.还有if else elif 这样的语句,也好多了.我的那个启动脚本更加明确了. mount 命令 fstabLinux mount 可以讲一块磁盘挂在一个目录下.挂载之后,这个目录原来的内容就不存在了.如果umount 之后,这个目录下面的空间就出现了,这一定和底层的实现有关系.操作系统究竟是如何管理存储空间的,这些问题都是需要研究的.目前,所指导的可以解决这些基本问题了,我可以很好的扩展我的系统空间不足的问题,但是我觉着对于 如果要解决这个问题,还需要一些挂载的知识,我需要讲自己的磁盘挂在系统上,让系统启动的时候自动帮我挂上.而不是每次都让我自己去挂.mount 里面也有很多. fstab 的编写,其实还可以,就是将最前面的盘符换成具体的磁盘设备就可以了.可以像下面这样,把你的磁盘随便挂上去.这就是 home分区分开使用的好处,单独挂载一个磁盘之后,就具备比较好的扩展性了.只要内容没有损坏,就可以随便安装到任何一个新系统上去.大部分内容都是放在/home里面的,或者可以把自己常用的软件都安装在一个指定的目录下,这个目录可以 UUID=684e471c-215b-4520-b3d6-09c6e5316ee2 / ext4 errors=remount-ro 0 1# swap was on /dev/sda6 during installationUUID=08488fed-d6f4-4fa2-b935-dd599851d98d none swap sw 0 0/dev/sda5 /home ext4 defaults,noatime 0 0 刚才遇到的问题好奇怪 挂在分区之后,输入密码进不来系统,我发现是我的新的home目录没有权限,把owner 改成我自己,然后就可以利用图形界面进来了. 我进来之后,发现我的steam 用不了了,我拷贝了所有的文件,发现还是不行,再后来发现是我的home中的所有的二进制文件都没有办法执行,上网找,发现是我的挂在参数有问题,用了defaults,noatime 之后就好了.真是神奇. 数据库支持utf8mb4，支持emojutf8mb4 兼容 utf8 如果数据库报这个错误，应该尝试将字段改成utf8mb4. General error: 1366 Incorrect string value: &apos;\\xF0\\x9F\\x8F\\xBC&apos; for column &apos;nick_name&apos; at row 1 ssh-agentto start your ssh-agent, you need to eval this command.eval ssh-agent -s 又是一个贪婪匹配的故事。这次是 grep，本来想用sed搞定的，但是发现用grep就非常足够了。我还会继续优化这一结果。在这方面，我还可以做的更好。有时候真得不知道打游戏能有什么作用。 我一共想出了2个shell，一个是利用sed的版本。cat bookmarks_4_27_15.html | sed &#39;s/ADD_DATE=\\&quot;.*\\&quot;//g&#39;另一个是利用grep的版本，但是grep的并没有达到我想实现的目的。sed的这个基本上是我想要的样子了。grep -i -Po &quot;HREF=\\&quot;.*?\\&quot;&quot; bookmarks_4_27_15.html sudo ntpdate 202.120.2.101sudo ntpdate 210.72.145.44这是两个时间服务器，可以调整自己的时间。 shell 执行字符串命令。可以这样。eval $cmddate &apos;+%Y-%m-%d&apos;httpd -Sshell 脚本中的 空变量。可能是你的程序报错，所以写判断的时候需要考虑变量为空的情况。如果出现这样的情况，报的错误可能是这个。&quot;[: =: unary operator expected&quot;a=$(($i + 1))同时满足2各条件if test &quot;$dev&quot; = &quot;0&quot; -a &quot;$devok&quot; = &quot;0&quot; ; then echo &quot;your comment&quot; echo &quot;your comment&quot;exit 1fi 如何调试shell。bash -x your.sh 就可以看你的shell的执行过程了。或者在shell的开始部分增加一行，set -x。 crontabcrontab l 列出当前的任务。分 时 日 月 星期 执行命令,* 表示任意的变量;在linux 下，你当前用户的crontab文件存放在 /var/spool/cron/ 目录下，这个文件以你的用户身份命名。 00 23 * * * run-your script 每天23:00 执行你的脚本。其实我需要做的就是一行命令。10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart 这个任务表示每周6和周日的1:10重启服务器。注意逗号，表示多个的意思。再看下面一个。* */1 * * * /usr/local/etc/rc.d/lighttpd restart 注意这个符号/ 表示每个一个小时重启一下服务器。 netstat –tunlp |grep 90 Linux 守护进程set_time_limit(0); 设置程序的执行时间,如果是0说明永久执行下去.学习写守护进程,用PHP实现.或这其他的也行.每个进程都有一个父进程,子进程退出,父进程能得到子进程退出的状态.进程组, 每个进程都属于一个进程组,这个号码等于该进程组组长的pid. 配置VIM为编辑器export VISUAL=vimexport EDITOR=”$VISUAL”git config –global core.editor “vim” 函数的返回值貌似可以用 $? 变量拿到。但是 return 是不支持返回非数字类型的。这是不是一个新的约束条件。对于数值运算，可以实用 expr 这个工具，其实这是另一个简单的工具，可以用 man 手册来查看帮助文档。shell 中有几个比较特殊的变量。$0 表示当前脚本的名字$1 $2 … $i 第 i 个参数$# 参数的个数。$? git fileMode这样你的git就不会官 fileMode 的变化了，默认的模式是 true 的。git config core.fileMode false","categories":[{"name":"shell","slug":"shell","permalink":"https://blog.nofile.cc/categories/shell/"}],"tags":[{"name":"awk","slug":"awk","permalink":"https://blog.nofile.cc/tags/awk/"},{"name":"sed","slug":"sed","permalink":"https://blog.nofile.cc/tags/sed/"},{"name":"grep","slug":"grep","permalink":"https://blog.nofile.cc/tags/grep/"}],"keywords":[{"name":"shell","slug":"shell","permalink":"https://blog.nofile.cc/categories/shell/"}]},{"title":"读书笔记","slug":"note-read","date":"2016-08-17T09:55:10.000Z","updated":"2016-08-17T09:55:10.000Z","comments":true,"path":"posts/生活/2016/08/17/note-read.html","link":"","permalink":"https://blog.nofile.cc/posts/生活/2016/08/17/note-read.html","excerpt":"","text":"关于阅读如果我一直以没有时间为理由，不去读书，是不是会越来越蠢。 Kindle资源 这个是一个不错的kindle资源网站。目前还比较好用。 https://www.jiumodiary.com/ 我的百度云里面也有不少书，想要的朋友可以从这里拿。https://pan.baidu.com/s/1i4TEMsH","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.nofile.cc/categories/生活/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://blog.nofile.cc/tags/阅读/"},{"name":"感悟","slug":"感悟","permalink":"https://blog.nofile.cc/tags/感悟/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://blog.nofile.cc/categories/生活/"}]},{"title":"Python 学习笔记","slug":"note-python","date":"2016-08-17T09:55:09.000Z","updated":"2016-08-17T09:55:09.000Z","comments":true,"path":"posts/programming/2016/08/17/note-python.html","link":"","permalink":"https://blog.nofile.cc/posts/programming/2016/08/17/note-python.html","excerpt":"","text":"Python 内置函数__call__ __getattr__这两个内置函数是非常有用的,首先这两个函数是可以给类定义的.只有在class中才能实现这两个函数.__call__ 这个方法,可以让对象的实例作为一个无名函数被使用.实际上是给class重定义了()运算符. 每次通过实例访问属性,都要经过 __getattributge__() 如果属性没有定义,还需要访问 __get_attr__() __getitem__, __setitem__, __delitem__ 这几个方法比较容易理解,就是对一个类的实例,可以按照下标的方式进行访问. 无需过多解释. 参考资料 http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html ####创建一个类的静态方法, def A(object):@staticmethoddef hello(): return \"hello world\"def world(self): return \"class instance method\" ####静态方法 class A(object):@classmethoddef foo(cls): print 'class name is',cls.__name__def python REGULAR EXPRESSIOn正则中的正向引用的问题，其实还是有一定的问题的。我发现下面的引用并不能成功,不知道是为什么。所以只能放弃\\1的写法，重复写前面的那个。期望可以匹配出字符串中的日期。这个正向引用的问题，希望以后可以有机会解决。 regex= r\"[\\d]&#123;4&#125;(-)[\\d]&#123;1,2&#125;\\1[\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str)str = ['nasdfasfd2015-12-31' , 'asdlasdff2015-12-11']regex= r\"[\\d]&#123;4&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str) file 你不知到的。 如果脚本是以相对路径被执行的，返回的是“” ， 并不会返回脚本当前目录。只有脚本是以绝对路径执行的时候，才会有对应的目录，这个问题需要注意。 shutil 可以操作文件目录，包括复制，移动，删除。比较常用。os.getcwd() 可以替代 os.path.dirname(file) , 这种方式有时候不如前者可靠。 python 变量不定义之前就使用是会报错的。 我发现上面的说法并不一定正确,getcwd 这个东西要小心使用,应该认真阅读一下这个方法的文档.它可能并不适用你的场景.在本质上,我需要的事这个东西. Python 获取当前脚本文件路径目录# -*- coding: cp936 -*-import sys,os#获取脚本文件的当前路径def cur_file_dir():#获取脚本路径 path = sys.path[0] #判断为脚本文件还是py2exe编译后的文件，如果是脚本文件，则返回的是脚本的目录，如果是py2exe编译后的文件，则返回的是编译后的文件路径 if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path) #打印结果print cur_file_dir() python excel 操作.完成了一个python 导入到处数据的功能.用到了这两个module xlwt, xlrd . 这个仅支持 xls 类型的excel. xlsx部支持.首先是安装 pip . sudo apt-get install python-devsudo apt-get install libmysqlclient-devsudo apt-get install python-pippip install mysql-pythonpip install xlwt pip install xlrd 数据库操作记得 commit .插入数据和写入数据的时候注意 转义.python MySQLdb 也可以绑定变量,这样可以不用关心特殊字符. 类似PHP. 全局变量的引用,应该使用global字段.python 从数据库中取出中文内容乱码.unicode 需要decode成utf8 的才可以,还需要其他的设置,完了需要一一验证. 下面是示例代码: 今天想到了python的爬虫框架。刚才查了一下，发现了scrappy这个东西。后面要找时间了解一下。http://www.jianshu.com/p/078ad2067419 python2.7的字符编码问题unicodedecodeerror: 'ascii' codec can't decode byte 0xef in position 0: ordinal not in range(128)import syssys.reload()sys.setdefaultencoding(\"utf-8\")","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/categories/programming/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.nofile.cc/tags/Python/"}],"keywords":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/categories/programming/"}]},{"title":"PHP 学习笔记","slug":"note-php","date":"2016-08-17T09:55:08.000Z","updated":"2016-08-17T09:55:08.000Z","comments":true,"path":"posts/programming/2016/08/17/note-php.html","link":"","permalink":"https://blog.nofile.cc/posts/programming/2016/08/17/note-php.html","excerpt":"","text":"PHP 回掉函数的使用。这是最基本的回掉方法。call_user_func_array(‘your function’,array());array() is your params. 刚才在文档里发现了好多东西，原来还是要自己编译才是最好的。才能够了解更多的特性。./configure –help其实已经包含了很多信息，只是你还不了解。要编译安装，这个是很重要的一步。 编译php常见的20个错误。http://crybit.com/20-common-php-compilation-errors-and-fix-unix/ PHP 扩展安装 PECLPECL is a repository for PHP Extensions, providing a directory of all known extensionsand hosting facilities for downloading and development of PHP extensions.PECL is very important. PHP 断言的使用。需要进行一些基本都的设置才可以。 assert_options(ASSERT_ACTIVE, 1);assert_options(ASSERT_BAIL, 1);$a = 'i1.23';assert(is_numeric($a));echo $a; PHP 正则表达式.preg_match 有几个关键词需要注意,一个是界定符 # / 这个可以自己设置的.preg_match 如果判断整个字符串的话,就要断言. 用 ^$.可以带 result 参数，将匹配的内容都放在这个result数组中。这个数组的参数应该是应用类型的。说到引用类型，我对这个还不是太清楚，没怎么使用过，应该熟悉一下。类似的函数还有 preg_match_all() , 返回值表示是否匹配.$name = \"hello\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'sas\";var_dump($name);$new_name = preg_replace(\"/\\\\\\*/\",\"\",$name);var_dump($name);var_dump($new_name); PHP urlencode, urldecode, rawurlencode, rawurldecode他们之间的差别还是比较小的,差别就是对+号的处理,我建议使用 rawurldecode, 而不是urldecode. 但这个改动不可以贸然,可能一起bug.在最初的时候设计的时候,就要考虑这一点. curl 参数curl 带json参数,需要加上-d 参数.没有这个参数是无法访问的.curl -d {goods_id:123123} “http://sss.ss.xx“ PHP array系列函数下面这个函数里面包含两种用法，一种是array_walk(), 还有一种是 变量的引用。这个和c语言是很相似的。$test = [1,2,3,5];array_walk($test , function(&amp;$i) &#123; $i++; &#125;);var_dump($test); PHP魔术方法__construct() 构造方法,生命类对象的时候就会调用.__desctruct() 析构方法,在类对象的生命周期结束之后. 这个和垃圾回收有什么关系吗.__call() must be public method.__callStatic() for static class method.get_called_class() 一般是在基类中用到.基础类库中用这个方法.get_class(). 得到当前类的名称.__autoload().static::class 和上面的得到同样的结果.PHP_EOL. 提高代码的可移植性. 换行符. mac windows, linux 下是不一样的.user_call_func() 这个方法是写自定义函数,利用这个方法,调用的函数会变成一个变量,所以非常灵活.user_call_func_array() 和上面的额方法类似,区别在于这里的方法的参数是数组.这些东西被统称为魔术常亮.__METHOD__ return the name of the function alongwith the class name.__FUNCTION__ just return the name of the function.__CLASS____FILE__ return filename of current file.__LINE__ return current line number.__DIR__ equal dirname(__FILE__). PHP SPL 方法 STANDARD PHP LIBRARYPHP 中spl 开头的一些方法是做什么的,比如spl_autoload_register.类似的方法还有不少,都是用来做什么的额.刚才调查了一下,确实有好多东西,这些都是PHP的高级语法,应该认真研究下,用好了,可以写出高效的代码. 对这门语言,我的了解还是不够,还需要认真研究.PHP SPL ==&gt; standard PHP library. PHP XHPROFXHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。一个函数的开销，可细分成调用者和被调用者的开销，XHProf数据收集阶段，它记录调用次数的追踪和包容性的指标弧在动态callgraph的一个程序。它独有的数据计算的报告/后处理阶段。在数据收集时，XHProfd通过检测循环来处理递归的函数调用，并通过给递归调用中每个深度的调用一个有用的命名来避开死循环。XHProf分析报告有助于理解被执行的代码的结构，它有一个简单的HTML的用户界面（ PHP写成的）。基于浏览器的性能分析用户界面能更容易查看，或是与同行们分享成果。也能绘制调用关系图。 PHP composerhttp://pkg.phpcomposer.com/ PHP 图像操作session_start();header(\"Content-type:image/png\"); $img_width=100;$img_height=20;srand(microtime()*100000);for($i=0;$i&lt;4;$i++)&#123; $new_number.=dechex(rand(0,15));&#125;$_SESSION[check_auth]=$new_number;$new_number=imageCreate($img_width,$img_height);//创建图象ImageColorAllocate($new_number,255,255,255); //设置背景色为白色for($i=0;$i&lt;strlen($_SESSION[check_auth]);$i++)&#123; $font=mt_rand(3,5); $x=mt_rand(1,8) + $img_width*$i/4; $y=mt_rand(1,$img_height/4); $color=imageColorAllocate($new_number,mt_rand(0,100),mt_rand(0,150),mt_rand(0,200));//设置字符颜色 imageString($new_number,$font,$x,$y,$_SESSION[check_auth][$i],$color);//输出字符&#125;ImagePng($new_number);ImageDestroy($new_number); PHP echo 和 print的区别。主要掌握echo的下面这两个特性。print更多的是一个函数。 echo \"hello\", \"world\";echo &lt;&lt;&lt;EOTtestEOT; PHP $_SERVER 变量PHP在命令行模式下的 $_SERVER 变量中的变量可以在shell 中 export 来设置.shell 中的变量会出现在SERVER 变量中.在web环境中,要通过在服务器中设置才可以. nginx 在 fastcgi_params 中设置. PHP session 和 cookiePHP 配置那天发现我本地环境速度很慢的原因是 php-fpm.conf 中的maxchildren 数量太少了。我改成static 的，然后把最大数量变成128； 一下子就不用排队了。当时的现象是这样的。我看network，显示网络请求在排队，但是我完了单独访问每一个排队排了很久的接口，速度都很快，所以很疑惑。 PHP 显示slowlog我开了php的slowlog，但是并没有出现slowlog。貌似php的slowlog并不是我理解的那样。并且slowlog，我自己写了一个sleep都不会打印出slowlog。","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/categories/programming/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"},{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"}],"keywords":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/categories/programming/"}]},{"title":"nginx 学习笔记","slug":"note-ng","date":"2016-08-17T09:55:07.000Z","updated":"2016-08-17T09:55:07.000Z","comments":true,"path":"posts/nginx/2016/08/17/note-ng.html","link":"","permalink":"https://blog.nofile.cc/posts/nginx/2016/08/17/note-ng.html","excerpt":"","text":"nginx编译参数./configure \\ --prefix=/home/service/nginx \\ --with-http_ssl_module \\ --with-http_spdy_module \\ --with-http_realip_module \\ --with-http_addition_module \\ --with-http_xslt_module \\ --with-http_image_filter_module \\ --with-http_sub_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_mp4_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_auth_request_module \\ --with-http_random_index_module \\ --with-http_secure_link_module \\ --with-http_degradation_module \\ --with-http_stub_status_module \\ --with-pcre=/root/src/pcre-8.37 \\ --with-zlib=/root/src/zlib-1.2.8 \\ --with-openssl=/root/src/openssl-OpenSSL_1_0_2d \\ --add-module=/root/src/naxsi-0.54/naxsi_src \\ --add-module=/root/src/headers-more-nginx-module-0.27 \\ --add-module=/root/src/echo-nginx-module-0.58 \\ --add-module=/root/src/lua-nginx-module-0.9.18rc1 \\ --add-module=/root/src/redis2-nginx-module-0.12 nginx 中加环境变量.fastcgi_params define_params hhh nginx 配置规则 location 写法。 log_format nginx 的log_format , log 需要几下post参数。记得上次查问题，我只能定位到url，并不能定位 到参数，这导致有些问题没有办法追查。 nginx 和php-fpmnginx 启动和重启检测配置文件的正确性，不要加载一个又明显错误的配置文件nginx -t -c /usr/nginx/conf/nginx.conf#启动 停止 或者重启 nginx 。nginx -s reload nginx #重新加载配置文件pkill nginx #停止nginx","categories":[{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/categories/nginx/"}]},{"title":"MAC 使用心得","slug":"note-mac","date":"2016-08-17T09:55:04.000Z","updated":"2016-08-17T09:55:04.000Z","comments":true,"path":"posts/Mac/2016/08/17/note-mac.html","link":"","permalink":"https://blog.nofile.cc/posts/Mac/2016/08/17/note-mac.html","excerpt":"","text":"MAC 使用心得安装vim 默认情况下，mac terminal中是带了vim 的。但是vim –version 看一下，发现是7.3版本的。这个版本的vim，和mac系统的clipboard交互有点困难。如果想将vim中的内容复制出来的话，会有点麻烦，这又是一个很常用的操作，所以很麻烦。查资料可以知道，7.4的vim可以支持。所以我们通过安装7.4版本的vim来解决这个问题。安装方式如下： brew install vim -clipboard -xterm_clipboard --with-client-server#上面的命令不能成功，出一个很奇怪的错误，所以就没有太纠结。brew install vim --override-system-vim#通过提示可以知道，安装后的vim在下面这这个路径,我们可以通过一个简单的alias搞定。alias v='/usr/local/Cellar/vim/7.4.2152/bin/vim' 然后再试一下，发现不管是terminal中的vim，还是tmux中都可以看到*寄存器了。有了这个寄存器，就说明我们的vim剪切板可以和clipboard之间交互了。 vim backspace不能删除内容的解决方案 可以通过增加配置来解决。 set nocompatibleset backspace=indent,eol,start MAC编译安装php nginx编译的过程中，很可能遇到这个问题。找不到openssl的header files。其实解决办法就是安装openssl。brew install openssl 。 但是只是安装了也可能报这个错误。找到了下面这个帖子。来自 stackoverflow。核心的是这个 brew install opensslbrew link openssl –force 遇到其他的报错，卡主了 confiture ，基本上用brew 安装那个就可以过关了。configure 过了之后，就可以make &amp;&amp; make install 了。 If you are on Mac OS X El Capitan, Apple doesn&apos;t include openssl any more because of security problems openssl had, I have similar problem installing Passenger. brew just installs openssl itself without development headers.If you are on an older version of Mac OS X than El Capitan, you can use: xcode-select --install which installs openssl development headers as well.EDIT:Updating brew and installing openssl and force linking openssl to brew version solved my problem:$ brew update $ which openssl /usr/bin/openssl $ brew install openssl$ brew link openssl --force $ which openssl /usr/local/bin/openssl","categories":[{"name":"Mac","slug":"Mac","permalink":"https://blog.nofile.cc/categories/Mac/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"}],"keywords":[{"name":"Mac","slug":"Mac","permalink":"https://blog.nofile.cc/categories/Mac/"}]},{"title":"javascript 学习笔记","slug":"note-js","date":"2016-08-17T09:55:02.000Z","updated":"2016-08-17T09:55:02.000Z","comments":true,"path":"posts/javascript/2016/08/17/note-js.html","link":"","permalink":"https://blog.nofile.cc/posts/javascript/2016/08/17/note-js.html","excerpt":"","text":"jquery常识如果$() 里面的()里面是一个dom元素的话，这个东西就是一个jquery对象。jquery 的方法，on ，可以绑定事件，each可以循环遍历数组。同事js自己的array也是一个对象，有foreach方法。要注意和jquery的each 方法区分。js 几个常用的事件。keyup onchange click js 的闭包函数，这几天php中也用了不少，一个是array_walk, usort()有些场景中用这些函数是很方便的，这些函数都有自己适合的场景，要在合适场景使用,才能体现出这些函数的作用。 js 正则.js localstoragejs localStorage.localStorage.getItem();localStorage.setItem(); underscore####jquery on 的代理实现 记得有这样一个场景。一个页面里面会使用到弹层，弹层上面有一些按钮，需要给这些按钮绑定事件。可以使用on方法绑定。但是在js代码执行的时候，这个坦层并没有出现，页面中并没有这个dom对象。这个时候，需要用到on的另一种使用方法。在他的父元素上绑定。parent.on(‘click’,’selector’,function(){})是一种类似这样的用法，当时这个解决了个很重要的问题。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/categories/javascript/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/tags/programming/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/categories/javascript/"}]},{"title":"C/C++ 学习笔记","slug":"note-c","date":"2016-08-17T09:55:01.000Z","updated":"2016-08-17T09:55:01.000Z","comments":true,"path":"posts/c/2016/08/17/note-c.html","link":"","permalink":"https://blog.nofile.cc/posts/c/2016/08/17/note-c.html","excerpt":"","text":"C文件的编译过程编译一个c文件，产生一个可执行文件，这个过程分为四个步骤 .c 文件到 .i 文件， --&gt; .s 文件 --&gt; .o 文件 --&gt; 可执行文件分别是预处理， 编译， 汇编， 链接 预处理所做的事情。 gcc -o helloworld.i helloworld.c -E 将 include 变成真实的东西 宏替换。 宏函数的优点。比一些函数要方便， 条件编译，对于程序的移植和调试，非常有用。 typedef 和 宏不一样的地方。给自己自定义的数据类型起一个别名。自定义的数据类型使用起来非常不方便。别名之后可以比较方便。typedef 是有作用域的。函数中的typedef，只能在函数中起作用。 ifndef 用法for example your .h file is named head.h and content like this. #ifndef _HEAD_H_#define _HEAD_H_this is your class definition area.#endif in your project, there are source file import it.for example. #include &lt;iostream&gt;#include \"head.h\"#include \"head.h\" if you include “head.h” twice, you find you can compile your file as well.but if your head.h is writte without #ifndef, #define #endif, then you mustwill get an error to stop your working. also, here the use of, #ifdef #else #endif this condition definition can save your release code size :). what is different between static type and dynamic type.static type: know when program is in compile process.dynamic type: know only in the run process. For pointer type. 计算一个数的算术平方根老师教过我们”牛顿迭代法快速寻找平方根”，或者这种方法可以帮助我们，具体步骤如下x= x+a/x;算法的原理其实不复杂，就是牛顿迭代法，用x-f(x)/f’(x)来不断的逼近f(x)=a的根。 float InvSqrt(float x)&#123; float xhalf = 0.5f*x; int i = *(int*)&amp;x; // get bits for floating VALUE i = 0x5f375a86- (i&gt;&gt;1); // gives initial guess y0 x = *(float*)&amp;i; // convert bits BACK to float x = x*(1.5f-xhalf*x*x); // Newton step, repeating increases accuracy return x;&#125; C++ rand lib#include &lt;stdlib&gt;srand((usigned)time(NULL));","categories":[{"name":"c++","slug":"c","permalink":"https://blog.nofile.cc/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://blog.nofile.cc/tags/c-c/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://blog.nofile.cc/categories/c/"}]}]}