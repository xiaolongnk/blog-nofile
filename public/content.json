{"meta":{"title":"xiaolong的博客","subtitle":"梦想是个好东西","description":"","author":"xiaolongnk","url":"https://blog.nofile.cc"},"pages":[{"title":"About","date":"2016-08-15T03:59:07.000Z","updated":"2017-05-08T15:32:28.578Z","comments":true,"path":"about/index.html","permalink":"https://blog.nofile.cc/about/index.html","excerpt":"","text":"经历2014年毕业,在美丽说,一直在HIGO这个部门，后面HIGO独立，随HIGO一起到新HIGO。 本科期间，喜欢打魔兽， 经常逃课去打游戏，学习成绩一般，能勉强过关的那种。 大二接触linux，之后就再也没有丢开过，花了很多时间去折腾。从桌面开始，从fedora, 到ubuntu，到arch， 再到ubuntu。在这方面花了不少时间。 觉着linux的命令行才是真正的命令行，linux桌面才是真正的桌面，虽然很不稳定，经常 崩溃又从头再来，并 且很容易出各种奇怪的问题，但当时觉着也没什么，遇到什么问题，就 去找那个问题，知道那个问题解决。比如， 有时候我折腾了一晚上，就是为了让我的 linux系统可以识别我的U盘。经常更新下显卡驱动，就搞得进不去桌面系 统，当时不太会，干脆 重装，于是又来一遍。总之，各种各样的问题，花了好多时间，但那时候的我，好像并不觉 得烦， 一遍一遍得重复，似乎还有不少乐趣。 一遍遍的重复，对linux也慢慢了解了，重装系统的次数也越来越少。意识到和系统折腾其实也意义不大。 于是将更多的精力放在了写cpp上。初次见面，就是从写cpp开始的。发现写一个cpp竟然不用建工程。写一个 文件就可以了。和windows上vc6.0臃肿工程相比，在linux上竟然如此简洁，给我的那种惊喜，在哪个瞬间就 将我的兴趣俘虏了。之后，写cpp基本就在linux上了。 大学期间的算法和数据结构，基本都是在linux写的。 大四的实习，宣布着我程序员职业生涯的开始。 刚开始的工作，就给我分到了后端组。发现学校里的学习还是帮了我不少。 短暂的实习结束，从天津来到北京，进 入HIGO。同样是做后端，除了没怎么用过PHP，但对服务器和mysql这些 东西我基本都是熟悉的，所以进入状态也很快， 大概过了一周，我就可以熟练的写业务代码了。 在框架中编写代码，有一个缺点就是大部分代码都是模仿，所以并不 难。也没有什么挑战。 后面，需要做运营后台。和接口不同的是，这里要求界面，需要用web前端相关的。被迫要写一 些前端页面相关 的东西，刚开始做的那段时间，有一些界面，确实是不小的挑战，然后就是各种补，各种查，各种加班， 磕磕绊 绊搞出来的东西，一来长得其丑无比，二来烂的就像一坨..，三来写法落后的一逼，但是那时候我们团队没有人 擅长啊，我做出来的东西，我也觉着不太行，就勉强可以用, 当时大家的心思都在集中在客户端，后台的东西， 差不多 能用就可以了,大家也表示可以理解。 后面，有反馈，说整个页面刷新极大的影响运营效率，我才学会了ajax局部更新数 据，将一些要紧的地方更新了下。 慢慢的，我也跟着了解着，学习着前端。 几乎同时，我还负责了我们推送系统的构建。当时，邻居团队的项目已经有了，直接送给了我们，因为是python做的。 我之前懂一点，于是这个项目就给我了。但其实我的当时的python水平就比helloworld水平高一点呀。但我还是很自信 的接过 来了，没关系，不会可以学吗。代码都有了，看不懂查查不就懂了。 就这样，我接手了我们的push系统。 这个项目，我一直维护到今年3月份。期间除了不少问题。主要我们的APP内有聊天系统。一方面是推送系统要和聊天系统 对接，他们之间有的较多的环节,这些环节的设计上有一些误差。另一方面，大概是因为我写代码的能力不够，当时还没 有能力构建一个健壮的应用，这应该也是主要原因吧。我的推送程序经常跑着跑着自己就挂了。不过迭代了几个版本之后， 也基本趋于稳定了。 其他的时间，几乎就一直是客户端发版，写一些临时的为大促准备的接口,和修bug。其实技术方面的挑战，真没什么。最大 的挑战我觉着就是事情太多，虽然都没什么技术含量，但是事情多呀，多到让你没有周末，周末在家里也不能安宁，一会又 问题，在群里@你，你就不能不看。那时候的周末，应该只比工作日好一点，好的地方就是可以在家办公。 就这样过了大概2年。7月中旬，决定辞职。2016年8月10号，离职。 感悟最近面试，有一个感觉就是，工作了2年，其实并不一直都是成长的。前面1年感觉还好，但是第二年就很马虎了。在面试的时候，发现好多知识都很零散，没有系统，没有一个纲领，所以后面一年中，自己出了问题，自己也不怎么感觉得到，日子就是在划水。 受此启发，前连天整理了下自己的知识体系(图一) 它并不表明我掌握了面列举的所有，但我学习的时间，基本上都是和他们有关，从另一方面来看，这也是以后发展的一个方向。不管做什么样的业务，在什么样的公司，希望自己不再迷芒,实在不知道该干什么时，可以从这个图上一点点来突破。"},{"title":"tags","date":"2016-08-17T06:15:40.000Z","updated":"2017-05-08T15:32:28.578Z","comments":true,"path":"tags/index.html","permalink":"https://blog.nofile.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"letsencrypt your site --- https","slug":"note-https","date":"2017-05-11T01:02:00.000Z","updated":"2017-05-11T01:12:53.368Z","comments":true,"path":"posts/2017/05/11/note-https.html","link":"","permalink":"https://blog.nofile.cc/posts/2017/05/11/note-https.html","excerpt":"","text":"让NGINX支持SSL需要编译时支持ssl，可以sbin/nginx -V 来查看confiture参数，如果当时没有支持，那么需要重新编译安装。 编译参数前面已经有一篇文章了。nginx编译参数,也不用全加，用--with-http_ssl_module 就可以了。 生成证书主要参考这个letsencrypty，可以生成免费证书。 生成方式也很简单，读上面的文章基本就能明白。ubuntu+nginx. ubuntu 用户的大致步骤如下： sudo apt-get install software-properties-commonsudo add-apt-repository ppa:certbot/certbotsudo apt-get updatesudo apt-get install certbot 给自己的服务器生成对应的认证文件,需要给每个域名都生成一下，下面指的是3个域名。 certbot certonly --webroot -w /yourpath1/lablog/public -d yourdomain1.comcertbot certonly --webroot -w /yourpath2 -d yourdomain2.comcertbot certonly --webroot -w /xxx/yourpath3 -d yourdomain3.com Automating renewal 上面生成的证书，有效期好像是90天，所以需要到期自己重新renewal一下。方法如下： sudo certbot renew // 只有过期才会生成sudo certbot renew --force-renew // 强制重新生成 执行完之后系统中会生成这些文件。 加密文件分析 每个域名的文件都会放在一个目录里面。live目录中的只是archive目录总文件的一个软链，没重新renew一次，archive中的文件都会多一个，表现为数字后缀的增加。同时live中的软链也会变成最新的有效的文件，软连名称不变，只是指向变成了较新的内容。如果感觉自己的renew有问题，或者renew过程中遇到了问题，可以直接将/etc/letsencrypt 这个目录直接删除，重新用上面的步骤重新设置一下我们的域名，然后对应的文件都会重新生成。执行完之后，我们可以通过sudo certbot certificates 查看我们的证书的详情，包括证书的存放位置，证书还有多少天过期等信息。 sudo certbot certificates 配置NGINX nginx 配置说明 配置就不多说了.首先需要配置2个server，监听2个端口。这样可以强制将80端口的请求重定向至443端口。https本身监听的是443端口。最主要的是ssl中间那3行。将步骤2中生成的对应key写在nginx的配置文件里。注意改成你的具体路径。 nginx 配置文件示例 server &#123; listen 443; server_name blog.nofile.cc; ssl on; ssl_certificate /xxxx/letsencrypt/live/yoursite/fullchain.pem; ssl_certificate_key /xxxx/letsencrypt/live/yoursite/privkey.pem; location / &#123; #这个地方指定被访问的文件夹位置 root /your/webroot/; index index.html; &#125;&#125;server &#123; listen 80; server_name blog.nofile.cc; return 301 https://blog.nofile.cc$request_uri; &#125; 配置好之后，重启nginx，应该就可以看到绿色的锁了。","categories":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}],"tags":[{"name":"https","slug":"https","permalink":"https://blog.nofile.cc/tags/https/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}]},{"title":"mysql 入门","slug":"note-for-mysql-tutor","date":"2017-05-08T14:58:00.000Z","updated":"2017-05-08T16:15:04.591Z","comments":true,"path":"posts/2017/05/08/note-for-mysql-tutor.html","link":"","permalink":"https://blog.nofile.cc/posts/2017/05/08/note-for-mysql-tutor.html","excerpt":"","text":"理论知识一、install mysql-server download your mysql-server from this link. https://cdn.mysql.com//Downloads/MySQLInstaller/mysql-installer-community-5.7.17.0.msi start your mysql-server , connect to your mysql server. 二、base class for mysql. mysql data types int , bigint , char , varchar , text , float , double , decimal , datetime ， timestamp some keywords ( select,from,where, order by,desc,asc,group by,+,-,*,/,left join,right join,on,in,between, insert,drop, delete ,alter….) show commands; show databases; show tables;show create table;desc command; create database create database yourdatabase ; 创建数据库。create tables for your database; 单列插入，批量插入。 insert data for yout tables (single data , batch insert); 删除操作。drop operations; drop data from tables; drop tables ; drop databases; 三、mysql query: single table select ; (select * from table where xxx); join table select; (select * from a , b where a.xx = b.xx and a.xx = ‘123’ order by a.xx); left join table select; select * from a left join b on a.x = b.x and a.c = b.c where a.x = ‘xx’ and b.c=’eee’; left join 的原理。 聚合操作： max min avg having order by , group by , limit , count; sub query; select * from A where A.x in (select B.x from b.xxx = ‘1231’ ); if (grade &gt; 70 , ‘low’ , ‘small’); if(value,t,f); select id,salary,if(salary&gt;300,’high’,’low’) from salary; ifnull(t,f) select id,salary,ifnull(salary,0) from salary; 四、mysql中的内置函数 now() date_add , date_sub(); interval 8 days; select date_add(now() , interval 3 day); select date_sub(now() , interval 1 day); month; upper , lower , left (name , 3) , right (name , 3);lenght(name) , SubString CurDate() 返回当前日期 CurTime() 返回当前时间 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 数据库表结构 we_student | Field | Type | Null | Key | Default | Extra | ---------------|-------------|------|-----|---------------------|---------------- | id | bigint(20) | NO | PRI | NULL | auto_increment | | group_id | bigint(20) | NO | | 0 | | | name | varchar(64) | NO | | | | | email | varchar(64) | NO | | | | | gender | char(1) | NO | | F | | | address | varchar(64) | NO | | | | | parents_phone | varchar(32) | NO | | | | | school_grade | smallint(6) | NO | | 1 | | | birthday | datetime | NO | | 1990-01-01 00:00:00 | | | ctime | datetime | NO | | CURRENT_TIMESTAMP | | | mtime | datetime | NO | | CURRENT_TIMESTAMP | | | status | smallint(6) | NO | | 1 | | we_class | Field | Type | Null | Key | Default | Extra | -------------------|---------------|------|-----|-------------------|----------------| | id | bigint(20) | NO | PRI | NULL | auto_increment | | name | varchar(64) | NO | | | | | class_description | varchar(2048) | NO | | | | | price | int(11) | NO | | 3000 | | | price_description | varchar(2048) | NO | | | | | ctime | datetime | NO | | CURRENT_TIMESTAMP | | we_group | Field | Type | Null | Key | Default | Extra | ------------|-------------|------|-----|-------------------|----------------| | id | bigint(20) | NO | PRI | NULL | auto_increment | | class_id | smallint(6) | NO | | 1 | | | starttime | datetime | NO | | CURRENT_TIMESTAMP | | | endtime | datetime | NO | | CURRENT_TIMESTAMP | | | teacher_id | bigint(20) | NO | | 0 | | | status | smallint(6) | NO | | 0 | | we_worker | Field | Type | Null | Key | Default | Extra | ------------|-------------|------|-----|-------------------|----------------| | id | bigint(20) | NO | PRI | NULL | auto_increment | | name | varchar(64) | NO | | | | | sex | char(1) | NO | | M | | | mobile | varchar(32) | NO | | | | | birthday | datetime | NO | | CURRENT_TIMESTAMP | | | card_id | varchar(32) | NO | | | | | wage | int(10) | NO | | 0 | | | department | bigint(20) | NO | | 0 | | | in_time | datetime | NO | | CURRENT_TIMESTAMP | | | out_time | datetime | NO | | CURRENT_TIMESTAMP | | | status | smallint(6) | NO | | 1 | | we_department | Field | Type | Null | Key | Default | Extra | -------------|---------------|------|-----|-------------------|----------------| | id | bigint(20) | NO | PRI | NULL | auto_increment | | name | varchar(32) | NO | | | | | description | varchar(2048) | NO | | | | | ctime | datetime | NO | | CURRENT_TIMESTAMP | | 创建数据库和数据表 创建数据表 /**学生表**/create table we_student ( id bigint(20) auto_increment, group_id bigint(20) not null default 0 comment 'group_id for the student', name varchar(64) not null default '' comment 'name of the student', email varchar(64) not null default '' comment 'email for the student', sex char not null default 'F' comment 'sex of the student', address varchar(64) not null default '' comment 'address of the student', parents_phone varchar(32) not null default '' comment 'parents mobile', school_grade smallint not null default 1 comment '1-6 for 初一 ~ 高三', birthday datetime not null default '1990-01-01 00:00:00', ctime datetime not null default CURRENT_TIMESTAMP , mtime datetime not null default CURRENT_TIMESTAMP , status smallint not null default 1 comment '1:normal , -1: delete', primary key (id)) engine = InnoDB , charset=utf8 , comment 'student table' ;/**课程表，记录所有的课程**/create table we_class ( id bigint(20) auto_increment comment 'class id for this class', name varchar(64) not null default '' comment 'name for this class.', class_description varchar(2048) not null default '' comment 'class description', price int(11) not null default 3000 comment 'price for this class', price_description varchar(2048) not null default '' comment 'description for price', ctime datetime not null default CURRENT_TIMESTAMP comment 'create time', primary key (id)) engine = InnoDB , charset=utf8 , comment 'all class table';/**table for teacher*/create table we_worker( id bigint(20) auto_increment comment 'id for teacher', name varchar(64) not null default '' comment 'teacher name', sex char not null default 'M' comment 'M for man , female for woman', mobile varchar(32) not null default '' comment 'mobile', birthday datetime not null default CURRENT_TIMESTAMP, card_id varchar(32) not null default '' comment 'wage card id', wage int(10) not null default 0 comment 'wage for the teacher', department bigint(20) not null default 0 comment 'depart id for this worker', in_time datetime not null default CURRENT_TIMESTAMP comment '入职时间', out_time datetime not null default CURRENT_TIMESTAMP comment '离职时间', status smallint not null default 1 comment '1: 在职 , -1:离职', primary key (id)) engine = InnoDB , charset=utf8 , comment 'table for teacher';/** table for departments **/create table we_department( id bigint(20) AUTO_INCREMENT comment '', name varchar(32) not null default '' comment 'department name', description varchar(2048) not null default '' comment 'description for this department', ctime datetime not null default CURRENT_TIMESTAMP, primary key (id)) engine = InnoDB , charset =utf8 , comment 'table for departments';/** table for groups: groups represents students set **/create table we_group( id bigint(20) auto_increment comment '', class_id smallint not null default 1 comment 'class id for this group', starttime datetime not null default CURRENT_TIMESTAMP comment 'start time for this group', endtime datetime not null default CURRENT_TIMESTAMP comment 'end time for this group', teacher_id bigint(20) not null default 0 comment 'worker id', status smallint not null default 0 comment '0: planning , 1:in process , 2: finished , -1: canceled', primary key (id)) engine = InnoDB , charset =utf8 , comment 'table for student groups'; 插入测试数据 insert into we_worker ( name , sex , mobile , birthday , card_id , wage , department , in_time , out_time) values('欧小龙' , 'M' , '18201176525' ,'1990-10-18' , '18201176525' , 10000 , 1 , '2017-07-13 00:00:00' , '0001-01-01 00:00:00');/* for we_group **/insert into we_group (class_id , starttime , endtime , teacher_id) values (1 , '2017-07-14 09:00:00' , '2017-08-14 00:00:00' , 1);insert into we_group (class_id , starttime , endtime , teacher_id) values (1 , '2017-07-14 09:00:00' , '2017-08-14 00:00:00' , 1);insert into we_group (class_id , starttime , endtime , teacher_id) values (1 , '2017-07-14 09:00:00' , '2017-08-14 00:00:00' , 1);insert into we_group (class_id , starttime , endtime , teacher_id) values (1 , '2017-07-14 09:00:00' , '2017-08-14 00:00:00' , 1);insert into we_department ( name , description ) values ('teacher' , '教工部' );insert into we_department ( name , description ) values ('adminstration' , '行政部' );insert into we_department ( name , description ) values ('finacial' , '财务部' );insert into we_department ( name , description ) values ('human resource' , '人力资源' );insert into we_class (name , class_description , price , price_description ) values ('c语言入门' , 'test ' , 30 , 'test'); SQL查询练习 习题 数据库操作，查看库和表结构 /** show database structure **/show databases;/** show tables **/show tables;/** select database **/use learning_sql;/** show table structure **/desc we_student;desc we_department;desc we_class;desc we_group;desc we_worker; 工资最高的worker，输出姓名和工资，按照工资从小到大排序 select , order by , limit select name , wage from we_worker order by wage desc limit 10; /**[ offset , size] **/select name , wage from we_worker order by wage desc limit 10 , 10;select name , wage from we_worker where wage = (select max(wage) from we_worker); 找出所有的员工的部门名称，输出 老师姓名和部门名称 left join select a.name as teacher_name , b.name as department_name from we_worker as a left join we_department b on a.department = b.id;select * from we_worker a left join we_department b on a.department = b.id; 找出每个老师带课的数量 group by , count select teacher_id , count(*) as class_num from we_group group by teacher_id order by class_num desc; 每个老师的id,工资， 带课数量 left join select a.name , a.id , b.class_num from we_worker a left join (select teacher_id , count(*) as class_num from we_group group by teacher_id) b on a.id = b.teacher_id where a.department = 1; 还没带班级的老师, 以及所有带班的老师 子查询，聚合函数 count，exists select * from we_worker where department = 1 and id not in (select distinct teacher_id from we_group);select * from we_worker where department = 1 and id in (select distinct teacher_id from we_group);select * from we_worker where department = 1 and not exists (select * from we_group where teacher_id = we_worker.id);select * from we_worker where department = 1 and exists (select * from we_group where teacher_id = we_worker.id); mysql 内置函数 date_add and date_sub, 以及数据 update update we_worker set in_time=date_add(in_time , interval 2 day) where id = 1;update we_worker set in_time=date_sub(in_time , interval 3 month) where id = 10; 入职满一年的员工 select * from we_worker where in_time &lt;= date_sub(now() , interval 1 year) ; 每个课程的开课数量 select class_id , count(*) as count from we_group group by class_id; 每门课程的 课程id , 开课数量，课程名称 select a.id , r.total, a.name , a.class_description from we_class as a left join (select class_id , count(*) as total from we_group group by class_id) r on a.id = r.class_id;select a.id , r.total, a.name , a.class_description from we_class as a left join (select class_id , count(*) as total from we_group group by class_id) r on a.id = r.class_id where r.total is not null; 找出还没开班的课程 , 多表 left join , 4 个表 select a.id from we_class a left join we_group b on a.id = b.class_id where b.id is null; select * from we_class a , we_group b where a.id = b.class_id; 这出一个 学生的姓名,班级开课时间,班级节课时间,课程名称，带课老师名称,下面是输出示例 |name | starttime | endtime | name | class_description | teacher_name | |----------|---------------------|---------------------|---------|---------------------|--------------| |张一凡 | 2017-07-14 09:00:00 | 2017-08-14 00:00:00 | c语言 | 基本c语言语法 | 000 | |王鑫 | 2017-07-14 09:00:00 | 2017-08-14 00:00:00 | c语言 | 基本c语言语法 | 000 | select a.name , b.id as group_id , c.name, c.class_description , d.name from we_student a left join we_group b on a.group_id = b.id left join we_class c on b.class_id = c.id left join we_worker d on b.teacher_id = d.id;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.nofile.cc/tags/mysql/"}],"keywords":[]},{"title":"npm update npm","slug":"note-node","date":"2017-03-06T15:35:00.000Z","updated":"2017-05-08T15:38:24.644Z","comments":true,"path":"posts/2017/03/06/note-node.html","link":"","permalink":"https://blog.nofile.cc/posts/2017/03/06/note-node.html","excerpt":"","text":"update npm with npmupdate npm it’s self is simple , just use this command. npm update -g npm please wait for a while , it may take several minutes. ####","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://blog.nofile.cc/tags/tags/"},{"name":"node","slug":"node","permalink":"https://blog.nofile.cc/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://blog.nofile.cc/tags/npm/"}],"keywords":[]},{"title":"shell while loop break","slug":"note-sh-01","date":"2016-12-03T08:47:00.000Z","updated":"2017-05-08T15:38:17.454Z","comments":true,"path":"posts/2016/12/03/note-sh-01.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/12/03/note-sh-01.html","excerpt":"","text":"shell while and breakshell 中的while 循环，也可以和break关键字配合使用，和其他程序语言类似。大体是一个do...done的格式。本文是一个简单的shell while的程序，可以用来检查你的程序是不是还活着。 包括一些简单的算术运算，在实际变成中比较常用。 代码#!/bin/bashcheckstr=&apos;redis&apos;num=1factor=5lifetime=1while :do cnt=`ps aux | grep $checkstr | grep -v grep | wc -l` if [ $cnt&apos;0&apos; -lt 1&apos;0&apos; ] then echo &apos;die&apos; break fi #sleep 5 seconds ((time=$lifetime*$factor)) echo &quot;live time [ &quot;$time&quot; ] seconds&quot; #this is another method for math operator lifetime=$((lifetime+1)) sleep 5done 运行结果如下","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://blog.nofile.cc/tags/shell/"}],"keywords":[]},{"title":"多说插件支持站点https","slug":"note-duoshuo-https","date":"2016-11-26T09:28:00.000Z","updated":"2017-05-08T15:38:05.270Z","comments":true,"path":"posts/2016/11/26/note-duoshuo-https.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/11/26/note-duoshuo-https.html","excerpt":"","text":"问题hexo 集成多说插件之后，对站点做了https 。https之后，要求页面里所有的引用资源都是htts协议的。但是多说的的官方js中的第三三方平台的头像没有做https，现在多说官方貌似没怎么维护了，去论坛逛了几圈，有人提问，但是官方没有回应。大概2个月前做了https改造的时候就发现这个问题了，当时没找到解决方案。当时简单尝试了一下，没有成功，加上我的blog也没设么评论，于是就放弃了。 解决方案今天浏览我的这篇文章发现竟然有一个评论，并且另外一篇文章也有。然后感觉没有那个绿色的锁很不舒服，于是再次长草了。打开浏览器，再次分析了下这个页面。发现页面中加载了多说的一个js ，embed.js，warning直接告诉我，是这个js有问题。查看站点请求的网络资源，发现相关的还有一个http接口。 embed.js 是压缩过的，整个页面只有2行，根本没法看，也没法调试。所以，先想办法将这个js替换掉，用一个格式化好的替换掉之后，可以给调试带来很多方便。 利用工具1我们可以将embed.js 处理一下，基本上可以看了。虽然变量被换成没意义的了，但是并不是太影响。处理之后的代码大概就是我们src中的样子。这个代码读起来会方便很多。先看了下这个代码，看了一会也没太看明白。于是再次回到console中。 从这个接口出发，在embed.js 中可以找到一些信息。用我们的格式化的js替换官方js。刷新页面，发现功能没有变化，说明替换js并不会影响功能。继续在浏览器中调试。这次可以试下浏览器的断点功能，在embed.js 中打一个断点。要在报出warning之前。然后单步调试，很快发现了浏览器出现warning的位置，发现这个之后，可以加一个更精确的断点。经过几次观察之后，我们可以定位到这个内容 在前面，js从api接口中获取到了数据，但是数据里面的图像是http的，而不是https的，我们猜想可以把里面的http强行换成https以了。按照我们的想法，在server上修改一下，并且加上log，发现还是不行，但是warning 变少了。 n.replace(&apos;http:&apos;,&apos;https:&apos;) 后面发现，原来javascript的replace就是只替换一个。于是找了replaceall的方法。用chrome的debug的过程如下。n.replace(/http:/g , &apos;https&apos;); 刷新页面，发现页面上的所有数据都变成了https 的了，锁变绿了，开心。 https站点的方法，可以参考我之前的blog. Github repo最终修改后的结果在我的xiaolongnk上.喜欢的可以star一下我。 参考资料： javascript beautifer chrome 单步调试","categories":[],"tags":[{"name":"https","slug":"https","permalink":"https://blog.nofile.cc/tags/https/"},{"name":"多说","slug":"多说","permalink":"https://blog.nofile.cc/tags/多说/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"}],"keywords":[]},{"title":"tcp简介","slug":"note-tcp","date":"2016-10-18T07:21:00.000Z","updated":"2017-05-08T15:38:10.332Z","comments":true,"path":"posts/2016/10/18/note-tcp.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/18/note-tcp.html","excerpt":"","text":"tcp简介TCP协议在不可靠的传输基础上实现了可靠的传输方案。一个tcp连接其实不是一个连接，它也是一个断断续续传输数据的过程，只不过给我们的感觉是有一个连接。要解决可靠传输和数据乱序的问题。 计算机网络四层模型 应用层(DNS , FTP , SMTP ,HTTP , SSH , TELNET)。 运输层(tcp,udp)。 网络层(ip,rip,icmp),路由器，rip协议，路由选择算法。ip地址，子网掩码。 链路层(arp , rarp)设备驱动程序,以太网协议，以太网,光纤。 tcp 协议。 tcp数据报头格式。ack , syn , window , src-port , dest-port. tcp三次握手，建立链接 断开链接 tcp 的可靠传输的实现原理。 数据重传机制,数据重传策略。(ACK , SYN , FIN)(SACK selective Acknowledgment)，需要在tcp头部加入新的字段，sack，sack和ack不一样,sack 的含义是，汇报收到的数据碎片,这个协议要求两边都支持sack,linux 下可以通过tcp_sack 来打开这个功能，linux2.4以后默认打开的。超时重传，接收端给发送端的ack确认只会确认最后一个连续的包。快速重传机制。D-SACK(duplicate). 数据校验，checksum。 tcp 的 rtt(round trip time) 算法， 超时时间。超时时间是根据网络情况，动态变化的。设长了，重发就慢，丢了老半天才重发，没有效率，性能差；设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。所以这个的选择算法也很是重要。 tcp拥塞控制和流量控制 tcp 的滑动窗口。tcp 需要知道实际的网络数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。这个window的作用是告诉发送端自己还有多少缓冲区可以用来接收数据,而不会导致接收端处理不过来。所以tcp会根据这个接收方的window来判断接收方可以接受多少数据，不会发送太多的数据，send window 一般是20个字节。滑动窗口一般会被分成4部分，@1已收到ack确认的数据@2已经发送但是还没有收到ack的数据@3在窗口中还没有发出的@4窗口以外的数据。工作过程是，接收端通过窗口滑动机制来控制发送端。发送方的window size 是由接收方告知的。 zero window 客户端的window会被server端给降成0，接收方有了window size之后会通过zwp包来通知发送。 一些关键词MTU 总共是1500字节。TCP 头部的内容大概是40个字节，出去头部，一个tcp可以运输的内容大概是1460字节的内容。这就是MSS(max segment size)。window sizesliding window","categories":[],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://blog.nofile.cc/tags/tcp/"},{"name":"network","slug":"network","permalink":"https://blog.nofile.cc/tags/network/"}],"keywords":[]},{"title":"tmux -- 终端复用","slug":"note-tmux","date":"2016-10-11T02:18:00.000Z","updated":"2017-05-08T15:38:02.849Z","comments":true,"path":"posts/2016/10/11/note-tmux.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/11/note-tmux.html","excerpt":"","text":"tmux 简介这里简单介绍一下tmux。tmux 是一个终端复用软件，类似的软甲有screen。但是现在的screen 用的人已经越来越少了。慢慢得会被tmux一统江湖。先不多说了，看一张效果图吧。 有时候，我们需要开多个terminal，大部分情况下，我们可以通过多个tab来完成。但是在我们不需要全屏展示的时候，这样感觉浪费。比如说我们需要一边写代码，一边看log，一边调试代码。这个时候，用多个tab的方式，效率就比较低了。有tmux之后，我们就可以都在一个terminal中完成这个操作了。 除了，终端分屏的功能，tmux还可以帮我们保存我们的工作session。我们在一个session中打开的tab都会被保存下来，我们可以中断当前的工作，去做其他的事情，在我们回来之后，我们还可以直接恢复我们原来的工作环境。所有打开的窗口会再次出现，就算关了terminal也没有关系。 并且现在有了session恢复插件之后，就算server重启了也没有关系了，我们的session依然可以恢复。 tmux可以支持鼠标了，不过这个功能要求tmux的version&gt;2.2 。如果比较就的系统，会给你配备1.6的tmux。这个时候，可能需要你自己编译一个tmux啦，具体的方法，可以参考前面那个tmux的链接啦。 总之，linux的软件，未经配置的是一个，配置好的是另一个，当然我说的易用性。tmux同样也有很强的定制性，具体的配置，可以参考我下面的配置。里面有一些简单的解释，不过不那么全。如果你很感兴趣，那么可以对其中自己不太明白的地方，自己搜索下,应该能获得很多新知识,可以帮助你更好的使用tmux。 如果你希望了解更多的tmux插件，你可以参考这个tpm tmux 配置set -g prefix ^qunbind ^b bind a send-prefix unbind '\"' bind - splitw -v unbind % bind \\ splitw -h bind r source-file ~/.tmux.conf \\; display \"Reloaded!\" unbind C-[ unbind C-] bind C-n new-session bind Tab last-window#set status-interval 1set-option -g status on set-option -g status-interval 1 set-option -g status-justify \"left\" set-option -g status-left-length 60 set-option -g status-right-length 90 set-option -g mouse on#选择分割的窗格bind k selectp -U #选择上窗格bind j selectp -D #选择下窗格bind h selectp -L #选择左窗格bind l selectp -R #选择右窗格#----------------------------------------------#重新调整窗格的大小bind ^k resizep -U 10bind ^j resizep -D 10bind ^h resizep -L 10bind ^l resizep -R 10bind ^u swapp -Ubind ^d swapp -D#----------------------------------------------# 颜色set -g status-fg whiteset -g status-bg cyan#设置终端颜色为256色 set -g default-terminal \"screen-256color\"# Use vim keybindings in copy modesetw -g mode-keys vi# 对齐方式set-option -g status-justify centre# 左下角# set-option -g status-left '#[bg=black,fg=green][#[fg=blue]#S#[fg=green]]'set-option -g status-left-length 20set-option -g allow-rename off# 窗口列表setw -g automatic-rename onset-window-option -g window-status-format '#[fg=yellow,bold]#I:#W#[fg=blue,dim]'set-window-option -g window-status-current-format '#[fg=green,bold][#[fg=blue]#I#[fg=blue]:#[fg=blue]#W#[fg=dim]#[fg=green,bold]]'# 右下角set -g status-right '#[fg=green,bold][#[fg=yellow,bold]%Y-%m-%d %H:%M:%S#[fg=green]]'# just for mac settings. install reattach-to-user-namespace first.# Copy-paste integration set-option -g default-command \"reattach-to-user-namespace -l zsh\"# Setup 'v' to begin selection as in Vimbind-key -t vi-copy v begin-selectionbind-key -t vi-copy y copy-pipe \"reattach-to-user-namespace pbcopy\"# Update default binding of `Enter` to also use copy-pipeunbind -t vi-copy Enterbind-key -t vi-copy Enter copy-pipe \"reattach-to-user-namespace pbcopy\"# Bind ']' to use pbpastebind ] run \"reattach-to-user-namespace pbpaste | tmux load-buffer - &amp;&amp; tmux paste-buffer\"# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'set -g @plugin 'nhdaly/tmux-better-mouse-mode'set -g @plugin 'tmux-plugins/tmux-yank'set -g @plugin 'tmux-plugins/tmux-resurrect'set -g @plugin 'tmux-plugins/tmux-continuum'set -g @plugin 'tmux-plugins/tmux-sidebar'set -g @plugin 'tmux-plugins/tmux-copycat'# for vimset -g @resurrect-strategy-vim 'session'# for neovimset -g @resurrect-strategy-nvim 'session'run '~/.tmux/plugins/tpm/tpm' 完整的配置文件在这里tmux-conf.我的github-tmux-conf tmux-conf 配置文件依赖 tmux-version &gt; 1.9 mac 下需要reattach-to-user-namespace brew install reattatch-to-user-namespae tmux 快捷键ctrl + q 是 prefixprefix + c 创建新窗口prefix + , 窗口重命名prefix + n 下一个窗口prefix + ctrl + n 开启一个新sessionprefix + tab 切换到上次工作的窗口prefix + d detach current tmux session ， 可以用tmux a命令重新恢复 tmux 常见问题 tmux title 经常改变 这个问题我是从stackoverflow上找到的， 原问题在这里,解决 方案是在tmux.conf中添加如下配置 set-option -g allow-rename off 当然，这个已经包含在我的配置文件里面了。 tmux 中 将vim中内容复制到系统剪切板。 还有就是tmux 中使用vim复制到系统clipboard中的问题。一般情况下，只有mac下好像才会有这个问题。 对应的修复方案也写在配置文件里了。如果是mac系统，直接用这个配置文件应该就可以了，另外需要自己 安装下依赖。 写在最后tmux 的包含session，session中可以有好多标签。有不少快捷键。刚开始记起来可能有点费尽，感觉有点像vim的学习过程。刚开始可能有点困难，但是一旦你适应了，对它足够了解了，的确会方便很多。加油吧。有问题欢迎发我邮箱，随时交流。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"https://blog.nofile.cc/tags/tmux/"}],"keywords":[]},{"title":"linux 标准开发环境","slug":"note-linux","date":"2016-10-11T02:18:00.000Z","updated":"2017-05-08T15:38:06.750Z","comments":true,"path":"posts/2016/10/11/note-linux.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/11/note-linux.html","excerpt":"","text":"在我们拿到一个刚被初始化的server之后，我们需要做一些配置工作，才能让这台server变成适合我们的工作机，一般来说，我通常会做下面这些准备工作。 配置zsh大部分学习linux的刚接触的基本都是bash，我之前也是，最近了解了zsh之后，发现zsh确实很强大，好多地方都很人性化，所以这里也推荐大家尝试一下，不喜欢的话可以再滚回bash。简单介绍一下zsh的优点： 强大的补全功能 git命令的完美支持 autojump 可以迅速切换目录，支持模糊匹配，比我之前了解的前缀匹配强多了上面这三点以前用bash的时候我都是自己在配置问价里面，集成了一些插件搞出来的，现在zsh里面都是现成的了。 zsh 和 oh-my-zsh 相关文章已经很多了，我也是参考了他们的文章开始的。 https://zhuanlan.zhihu.com/p/19556676 sudo apt-get install zshwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | shchsh $USER -s $(which zsh) #将系统的bash换成zshwget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gztar -zxvf autojump_v21.1.2.tar.gzcd autojump./install.shplugins=(git autojump)[[ -s ~/.autojump/etc/profile.d/autojump.zsh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.zsh ./install.sh安装完之后，会提示我们将[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh这一行加入到我们的.zshrc里面，写的位置需要注意一下，一定要放在.zshrc中source $ZSH/oh-my-zsh.sh这一行的前面。否则会出现需要执行2此source ~/.zshrc 才会生效的现象。 zsh 的插件，默认会装git，我这里装了autojump。配置过程中，遇到了任何问题，请参考上面那个链接。 基本的配置 vim，基本的编辑器，对我来说，只会用vim，nano都不怎么会，emacs更是不用提。vim的初始化，这里有一套比较成熟的配置文件，可以比较方便的搞定，一般情况，可以将一些个人习惯的配置脚本化，我就这样做了，基本软件的安装可以用脚本很方便的完成。需要配置常用的扩展，并配置正确的vimrc。可以参考我的那篇vim的文章。 git 需要搞定~/.gitconfig openssh-server 默认情况下，需要安装这个，才可以远程ssh连接。 ag 一个更强大的grep，类似的还有acksudo apt-get install vim-gtksudo apt-get install git tigsudo apt-get install openssh-serversudo apt-get install silversearcher-ag 标准的web环境通常来说，一套相对简单的web开发环境，服务器软件到，php，再到存储层，包括需要以下这些组件的支持。 nginx 编译安装，参考编译nginx的文章 php 编译安装，参考编译php的文章 php扩展 (redis , memcached , imagic , gmagic) 编译安装 mysql (可靠存储) redis (缓存) memcached (缓存) 安装命令: sudo apt-get install mysql-serversudo apt-get install redis-serversudo apt-get install memcached python(2.7) 环境 pip , ipython Scrapy python的爬虫框架 python-openssl-dev 安装命令如下:sudo apt-get install python-pipsudo apt-get install python-openssl-devsudo -H pip install --upgrade pipsudo -H pip install Scrapy node 环境 nvm (node version manager) npm (node package manager) 安装完nvm需要重启一下shell。或者source 一下你的.zshrc 或者 .bashrc。 wget -qO- https://raw.github.com/creationix/nvm/v0.4.0/install.sh | shnvm install 0.10sudo apt-get install npmnpm install -g cnpm --registry=https://registry.npm.taobao.org或者下面这个echo &apos;\\n#alias for cnpm\\nalias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \\ --cache=$HOME/.npm/.cache/cnpm \\ --disturl=https://npm.taobao.org/dist \\ --userconfig=$HOME/.cnpmrc&quot;&apos; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrcnpm install hexo-cli -g npm 淘宝镜像https://npm.taobao.org/安装hexo https://hexo.io php 相关 composer (php package manager) laravel 安装composercurl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composer 更多参考，请看这里","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"},{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"zsh","slug":"zsh","permalink":"https://blog.nofile.cc/tags/zsh/"},{"name":"spider","slug":"spider","permalink":"https://blog.nofile.cc/tags/spider/"}],"keywords":[]},{"title":"PHP编译安装","slug":"note-phpcompileinstall","date":"2016-10-11T02:18:00.000Z","updated":"2017-05-08T15:38:23.456Z","comments":true,"path":"posts/2016/10/11/note-phpcompileinstall.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/11/note-phpcompileinstall.html","excerpt":"","text":"php 编译 下载php源码 安装一些以来的库，如果这些库缺失的话，configure 会失败。也可以失败一次安装一个。这类问题的解决方案相对简单，在linux上用apt-get 安装对应的库就可以了。不行的话，用搜索引擎找一下就会有大片的解决方案，随便一个都可以拿来参考。sudo apt-get install libcurl4-openssl-devsudo apt-get install libssl-devsudo apt-get install libxml2-dev./configure --prefix=/yourpath/php --with-config-file-path=/yourpath/php/etc --with-mysql=/usr/ --with-iconv-dir=/usr/ --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --with-curl --with-mcrypt --with-gd --with-openssl --with-mhash --with-xmlrpc --with-zlib --with-pdo-mysql --with-mysql=shared,mysqlnd --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-fpm --enable-mbstring --enable-gd-native-ttf --enable-pcntl --enable-sockets --enable-zip --enable-pdo --disable-rpath 配置中我们开启了好多功能，有好多我们都不知道是干什么的，没关系，好奇的同学们可以先./configure --help来了解下，这个问题先留着，后面有空了我们开专题专门堂研究下这个问题。 可能会遇到的问题。 openssl.h not found libxml2 没有安装 jpeglib.h not found pnglib.h not found freetype-config not found mcrypt.h not found sudo apt-get install libxml2-devsudo apt-get install pkg-configsudo apt-get install libssl-dev libsslcommon2-devsudo apt-get install libjpeg-devsudo apt-get install libpng++-devsudo apt-get install libfreetype6-devsudo apt-get install libmcrypt-dev make -j4 -j4 这个参数不是必须的，如果你的电脑是4核的，这样会加快编译速度。 php 扩展安装 下载php扩展，比如phpredis ，可以直接来这里找https://pecl.php.net/ 进入php扩展目录，操作如下： /your/path/phpize ./configure makemake install 如果按照上面的方法安装扩展的时候还是会失败，那么可以换一个版本的扩展再试下。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"},{"name":"php-extension","slug":"php-extension","permalink":"https://blog.nofile.cc/tags/php-extension/"}],"keywords":[]},{"title":"读书笔记","slug":"note-read","date":"2016-10-09T06:38:00.000Z","updated":"2017-05-08T15:38:21.047Z","comments":true,"path":"posts/2016/10/09/note-read.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/note-read.html","excerpt":"","text":"关于阅读如果我一直以没有时间为理由，不去读书，是不是会越来越蠢。 Kindle资源 这个是一个不错的kindle资源网站。目前还比较好用。 https://www.jiumodiary.com/ 我的百度云里面也有不少书，想要的朋友可以从这里拿。https://pan.baidu.com/s/1i4TEMsH 读过的书 基督山伯爵 埋下仇恨，绝境中看到希望，逃生，获得意外的财富，体面的复仇。复仇复了好久，阅尽人间繁华，而不沉溺，实在厉害。 鲁滨逊漂流记 这个是自己打猎，落入荒岛，也是尽力生存，最后找到机会出去了，也获得了一笔意想不到的财富，过上了幸福的生活。 肖申克的救赎 有点励志，要抓住任何可以抓住的机会，不管处境多么难，都要有梦想，做成想做的事，永远不要放弃。 神雕侠侣 最近读完的,电视剧看了好久了，读小说感觉还是很不错的。读小说我只认人物，对杨过有不少喜欢，但感觉他并不完美，有时候也有些讨厌，不过这也算是正常的吧，哪里有完美的人，孰能无过。最讨厌的角色，感觉就是郭芙了,还有姓武的那两个小傻子。 明朝那些事 现在想来，看得基本都完了，有一点点印象，想到这本书现在只有一个想法，历史一直在重演，只不过是换了一批人。 貌似只读了这么多，可以看出来，我读书不多。","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://blog.nofile.cc/tags/阅读/"},{"name":"感悟","slug":"感悟","permalink":"https://blog.nofile.cc/tags/感悟/"}],"keywords":[]},{"title":"Path Sum II","slug":"ag-113","date":"2016-10-09T04:02:00.000Z","updated":"2017-05-08T15:37:43.563Z","comments":true,"path":"posts/2016/10/09/ag-113.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-113.html","excerpt":"","text":"Path Sum II和112类似，不过这次是要求出所有的解决方案。 For example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 return [ [5,4,11,2], [5,8,4,5] ] 分析简单的DFS，本质上是遍历所有的节点，找到解决方案，然后存储。需要注意的是，python的listcopy的时候需要用到deepcopy才行。可以用内部函数来简化编码。 代码import copyclass Solution(object): def pathSum(self, root, mSum): \"\"\" :type root: TreeNode :type sum: int :rtype: List[List[int]] \"\"\" ltMap = [] def travelRoot(root , currentVal , ltTmp): if root == None: return if root.left == None and root.right == None and root.val + currentVal == mSum: ltTmp.append(root.val) ltMap.append(copy.deepcopy(ltTmp)) return travelRoot(root.left , currentVal + root.val , ltTmp + [root.val]) travelRoot(root.right, currentVal + root.val , ltTmp + [root.val]) travelRoot(root , 0 , []) return ltMapdef run(): from common import CommonUtil root = None root = CommonUtil.generateTree(root) CommonUtil.printTree(root , 0) ns = Solution() ret = ns.pathSum(root , 17) print ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://blog.nofile.cc/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"Path Sum","slug":"ag-112","date":"2016-10-09T02:49:00.000Z","updated":"2017-05-08T15:37:46.068Z","comments":true,"path":"posts/2016/10/09/ag-112.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-112.html","excerpt":"","text":"Path SumGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 分析应该就是一个简单的DFS.代码里面的common class 是为测试写的类,实现在这里。因为最终有没有只能等到叶子节点才能知道，所以说只要每个节点的2个叶子中有一个返回True，那么就存在这个方案。 代码# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: bool \"\"\" currentVal = 0 return self.travelRoot(root , currentVal , sum) def travelRoot(self , root , currentVal , tSum): if root == None: return False if root != None and root.left == None and root.right == None: if currentVal + root.val == tSum: return True l1 = self.travelRoot(root.left , currentVal + root.val , tSum) l2 = self.travelRoot(root.right, currentVal + root.val , tSum) return l1 or l2def run(): from common import CommonUtil root = None root = CommonUtil.generateTree(root) CommonUtil.printTree(root , 0) ns = Solution() ret = ns.hasPathSum(root , 17) print ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://blog.nofile.cc/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"Best Time to Buy and Sell Stock","slug":"ag-121","date":"2016-10-09T02:37:00.000Z","updated":"2017-05-08T15:37:51.161Z","comments":true,"path":"posts/2016/10/09/ag-121.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-121.html","excerpt":"","text":"Best Time to Buy and Sell Stock题目要求是如何购买可以获益最大,比较简单，但还是比较有意思的。两个样例如下： Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0 In this case, no transaction is done, i.e. max profit = 0. 分析我们有两个变量，分别是购买价格和最大获益值。开始的时候先购买第一天的，然后后面每一天都这样判断，如果当天的价格小于上一次购买，那么把上一次购买换成今天的价格，如果不小于的话，那么看当天的获益是不是比前面一次的获益多，如果是的话，就更新一下最大获益值。 代码class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) == 0: return 0 bought_price = prices[0] max_benefit = 0 for i in prices: cnp = i - bought_price if cnp &lt; 0: bought_price = i elif cnp &gt; max_benefit: max_benefit = cnp return max_benefit def run(): sol = Solution() tst = [7, 1, 5, 3, 6, 4] ans = sol.maxProfit(tst) print ans pass","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://blog.nofile.cc/tags/dynamic-programming/"}],"keywords":[]},{"title":"前端笔记","slug":"note-web","date":"2016-09-09T06:43:00.000Z","updated":"2017-05-08T15:38:11.536Z","comments":true,"path":"posts/2016/09/09/note-web.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-web.html","excerpt":"","text":"marginmargin: 的4个参数。up ,right, down , left;如果只有一个参数，那么表示4个都是n px。可以是1–4个参数。 some input typeradio, checkbox , button, 他们都有对应的时间，可以在里面添加对应的 函数。可以带参数的。checkbox 也可以写成数组。name=’chk[]’ $_REQUEST [‘chk’] 取值的方式是这样的。 fontawesome学习两个前端页面会使用到的js. https://www.woothemes.com/flexslider/ 这个是用来做轮播图的js。http://fontawesome.dashgame.com/这个是用来给页面中显示一些字体用的。还有一些常用的图标，用法也很简单， html meta 标签304 错误. 强制不从本地设备读取内容. &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt; 在页面中中使让一段文字在一个div中垂直居中？http://stackoverflow.com/questions/79461/vertical-alignment-of-elements-in-a-div","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://blog.nofile.cc/tags/html/"},{"name":"css","slug":"css","permalink":"https://blog.nofile.cc/tags/css/"}],"keywords":[]},{"title":"shell 学习笔记","slug":"note-shell","date":"2016-09-09T06:42:00.000Z","updated":"2017-05-08T15:38:25.828Z","comments":true,"path":"posts/2016/09/09/note-shell.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-shell.html","excerpt":"","text":"awkthe follow command can be used to restart php-fpm in server.ps aux | grep ‘php-fpm’ | awk ‘{print $1}’ | xargs kill -USR2-F option 是用来改变默认的分隔符的。awk -F ‘:’ ‘{print $3}’awk 的 BEGIN 和 END 语句的功能。BEGIN 是最开始的部分执行的，然后AWK开始读取文件内容，进行处理。END 是最后面结束执行的.$NR 是拿到最后一列。 sed笔记sed &apos;s/xx/ds/&apos; note[ ! -x result ] &amp;&amp; mkdir resultfor i in `ls *.grb`do out=`echo $i | sed &apos;s/GLDAS_NOAH10_M.A//&apos; | sed &apos;s/\\..*[[:graph:]]//&apos;` wgrib $i &gt; result/$out&quot;.out&quot;donesed -i &quot;This command to use replace the input file&quot;just a simple example.sed -i &apos;s/--/-/&apos; mac 下sed -i 的问题 sed -i &apos;s/a/b&apos; #linux stylesed -i &apos;&apos; &apos;s/a/b/&apos; #mac style , mac 上的sed要求给一个备份文件的文件名，会在替换前做一个备份，#不需要的话给个空参数，就不会备份。 前面的那个空格不能少 d 表示是删除的意思。用新文件覆盖旧文件。sed ‘/vim/d’ ~/.bashrc &gt; ~/.bashrc grepgrep -E 支持扩展的正则grep -o 只输出指定内容, only-match 的含义grep -F 相当于 fgrepgrep -v 不匹配指定正则的指令grep 输出匹配内容的上下两行内容,输出上下文,记得这个参数.grep -C 2 ‘linux’grep -i 进行大小写无关的搜索grep -P perl分格的正则 grep -i -Po &quot;HREF=\\&quot;.*?\\&quot;&quot; bookmarks_4_27_15.html find使用的例子下面这个script结合了find 的regex参数的用法。find regex 和 那么的区别还是挺大的。regex搜索的输出是全名的，name知识一个短的名字。 #!/bin/bash# 要搜索的路径。path=&quot;$HOME&quot;for i in `find $path -regex &quot;.*/[0-9]\\&#123;6\\&#125;/*&quot; -type d 2&gt;/dev/null`do echo $i for j in `ls $i` do echo $j m=`echo &quot;$j&quot; | cut -d. -f2` if [ $m != &apos;log&apos; ] then echo &quot;mv for $j&quot; mv $i&quot;/&quot;$j $i&quot;/&quot;$j&quot;.log&quot; fi donedone shell重定向来自这个链接 http://www.cnblogs.com/yangyongzhi/p/3364939.html ./Test.py 1&gt;normal 2&gt;error 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3./Test.py 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 1&gt;normal 2&gt;error 可以通过这两个命令看出差别,其实就是从右向左执行的. 具体的执行过程是这样的,一个完整的shell指令的执行是从右往左的.先执行 1&gt;&amp;3 , 然后执行 2&gt;&amp;1 , 3&gt;&amp;2 nohup的使用在mac中，在tmux中使用nohup会有问题，会抛出下面这样的错误。所以只能在开一个终端执行。nohup: can’t detach from console: Undefined error: 0nohup redis-server &amp; &gt;/dev/null git 笔记一个项目可以添加多个源,origin是默认的一个源.并且也可以跨源合并.这是比较高级的用法.如果要跨项目合并. git 跨项目合并. git remote add code “url”git push code master git remote add. 将一个远端的项目添加到新的分支上,然后可以合并。git remote add name git@gitlabserver.meiliworks.com:higo/api.git删除这个分支。git remote rm old_pandoragit 将某个分支强制覆盖。比如我想用newpush 的代码完全覆盖 master 的代码。可以这样做。git push origin newpush:master -f git remote add origin url #这样可以讲自己的git目录添加到远端仓库.很方便.同一个项目可以添加多个远端仓库,可以一起使用. git config –global core.editor “vim”git config core.fileMode false这样你的git就不会官 fileMode 的变化了，默认的模式是 true 的。 shell get your ipifconfig | grep -E -o &quot;inet ([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1ip a| grep -E -o &quot;inet addr:([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1 linux 下 ifconfig | grep ‘inet ‘ | awk ‘{split($2, ip_cntr, “:”); print ip_cntr[2];}’netstat –tunlp |grep 90 shell functions函数的返回值,函数的参数.http://www.jb51.net/article/33895.htm这里看到了一些参考,主要是这两个参数, $@ 和 $* 是一样的,可以将函数的参数当做一个字符串.如果你仍然利用$1,$#,$0这些而参数,那么你可能得不到你想要的结果. shell 执行字符串命令。可以这样。eval $cmddate &apos;+%Y-%m-%d&apos;httpd -Sshell 脚本中的 空变量。可能是你的程序报错，所以写判断的时候需要考虑变量为空的情况。如果出现这样的情况，报的错误可能是这个。&quot;[: =: unary operator expected&quot;a=$(($i + 1))同时满足2各条件if test &quot;$dev&quot; = &quot;0&quot; -a &quot;$devok&quot; = &quot;0&quot; ; then echo &quot;your comment&quot; echo &quot;your comment&quot;exit 1fi shell中函数的返回值貌似可以用 $? 变量拿到。但是 return 是不支持返回非数字类型的。这是不是一个新的约束条件。对于数值运算，可以实用 expr 这个工具，其实这是另一个简单的工具，可以用 man 手册来查看帮助文档。shell 中有几个比较特殊的变量。$0 表示当前脚本的名字$1 $2 … $i 第 i 个参数$# 参数的个数。$? 如何调试shell。bash -x your.sh 就可以看你的shell的执行过程了。或者在shell的开始部分增加一行，set -x。 crontab l列出当前的任务。分 时 日 月 星期 执行命令,* 表示任意的变量;在linux 下，你当前用户的crontab文件存放在 /var/spool/cron/ 目录下，这个文件以你的用户身份命名。 00 23 * * * run-your script 每天23:00 执行你的脚本。其实我需要做的就是一行命令。10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart 这个任务表示每周6和周日的1:10重启服务器。注意逗号，表示多个的意思。再看下面一个。* */1 * * * /usr/local/etc/rc.d/lighttpd restart 注意这个符号/ 表示每个一个小时重启一下服务器。","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.nofile.cc/tags/shell/"},{"name":"awk","slug":"awk","permalink":"https://blog.nofile.cc/tags/awk/"},{"name":"sed","slug":"sed","permalink":"https://blog.nofile.cc/tags/sed/"},{"name":"grep","slug":"grep","permalink":"https://blog.nofile.cc/tags/grep/"}],"keywords":[]},{"title":"sphinx学习笔记","slug":"note-sphinx","date":"2016-09-09T06:42:00.000Z","updated":"2017-05-08T15:37:53.822Z","comments":true,"path":"posts/2016/09/09/note-sphinx.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-sphinx.html","excerpt":"","text":"sphinx实践用shpinx实现一个搜索相关的小项目需要安装sphinx，然后和mysql配合使用。 sphinx安装配置编译安装sphinx。 中文分词需要下载一个中文字典，应该有好多现成的。","categories":[],"tags":[{"name":"sphinx","slug":"sphinx","permalink":"https://blog.nofile.cc/tags/sphinx/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.nofile.cc/tags/搜索/"}],"keywords":[]},{"title":"mac常用软件","slug":"note-software","date":"2016-09-09T06:42:00.000Z","updated":"2017-05-08T15:38:09.151Z","comments":true,"path":"posts/2016/09/09/note-software.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-software.html","excerpt":"","text":"charles APP代理软件charles 破解。我的link。 http://pan.baidu.com/s/1i4UUbOh Dash非常便捷的API手册，方便查询。 PhpStormPHP 开发的好帮手，可以帮你避免一些低级错误。 WebStorm和Phpstorm是同一个公司开发的，使用上和PhpStorm 差不多,用于偏前端的开发工作场景。 ipythonPython 命令行工具，和Python不同的是，这个可以进行命令提示，方便初学者。 Postman管理接口，方便重用，经常和一堆接口打交道的话，这个会很方便。 以上貌似除了postman，其他的都是付费的。不过买起来确实很贵，但破解都 相对容易，需要的话，请自行百度，都很简单。","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"},{"name":"工程效率","slug":"工程效率","permalink":"https://blog.nofile.cc/tags/工程效率/"}],"keywords":[]},{"title":"Ubuntu学习笔记","slug":"note-ubuntu","date":"2016-09-09T06:42:00.000Z","updated":"2017-05-08T15:38:18.654Z","comments":true,"path":"posts/2016/09/09/note-ubuntu.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-ubuntu.html","excerpt":"","text":"tmux vim slowstarttmux 中vim slow start 的原因,就是因为开了多个tmux,启动速度就变慢了.查看了slowlog,发现是因为xsmp消耗了大概1s的时间.只要保证一个tmux运行就可以了. 让你的ubuntu文件夹变成彩色的.可以添加下面的ppa,添加这个sudo add-apt-repository ppa:costales/folder-color然后安装下面这个 folder-color 就可以了.sudo apt-get install folder-color ubuntu get source code如何获取ubuntu的源码你可以获取任何一个你所使用的源码包.这就是开源的系统.只要你的系统的源里有dep-src 这个选项,那么就可以随便获得系统源码.就像下面这样. deb-src http://archive.canonical.com/ubuntu trusty partnerdeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty universedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universedeb-src http://extras.ubuntu.com/ubuntu trusty maindeb-src http://security.ubuntu.com/ubuntu trusty-security main restricteddeb-src http://security.ubuntu.com/ubuntu trusty-security multiversedeb-src http://security.ubuntu.com/ubuntu trusty-security universe使用下面的命令.sudo apt-cache showsrc gedit #showsrc 可以用来查询有没有你需要的源码包sudo apt-cache source gedit #source 命令用来获取你需要的源码包 ubuntu自己编译出deb当然在这些工作之前,我们需要确保安装一些基本的工具.dpkg-dev 先安装这个. 在编译源码包之前,需要安装具有依赖关系的软件包,可以使用这个命令,就是上面的那个.build-dep 命令. sudo apt-get build-dep xxx#通过上面两个命令,就可以得到自己的源码包了.然后利用cd yoursrcsudo dpkg-buildpackage 这样就可以得到你的dep文件了.可以使用下面的命令来安装deb文件.sudo dpkg -i *.deb 有了上面的知识,你就可以利用自己的系统,学习各种工具的源码了,包括vim , emacs.加油吧.^_^ ubuntu desktopfirefox 插件 json, vimperator, firebug.chrome插件 json , vimium , 登录自己的账号之后，可以同步chrome插件和书签，很方便 ubuntu 关闭没用的 crash report。执行sudo vim /etc/default/apport 把那个1 改成0ubuntu 上换显卡驱动要谨慎，很容易就重登陆之后就进不去系统了。如果进不去系统了，那就去认真google吧。我曾经折腾过，这里就不记录了，总之不建议在在ubuntu上折腾太多桌面的东西，linux是用来做server的，好多经典的软件都是no gui的。所以应当将精力放在server这边来，桌面的话，简单玩玩就可以了。 在你的本地文件里面. .local/share/applications/ 里面把对应的删除,重新登陆就可以看到你讨厌的那个东西不见了. 重启linux的图形界面startx sudo service start lightdmlspci 和 glxinfo | head 如果显卡驱动有问题，这个命令会不正常。正常的话，会列出来一些相关的东西。 modinfo系统默认安装的驱动是这个。xserver-xorg-video-intelmodprobe -r nouveau 用这个命令来卸载这个模块，从内核中卸载这个模块。 ubuntu firefox flash sudo apt-get install flashplugin-downloader 在linux中,我想升级gedit,比如说我的是 ubuntu14.04, 但是在 ubuntu15.10 里面,gedit 的版本是比我的新的.但是在14.04里面我确用不了最新的gedit .这个时候,我可以从官网下载最新的gedit ,安装,然而安装的时候会出现一些问题.这时候怎么办呢.可以这样. sudo apt-get build-deb gedit 然后执行安装命令就可以了.安装应该不会出错了. ubuntu 创建自定义的快捷方式launcher。ubuntu launcher. alacarte在mate桌面上安装创建自己的启动方式．要给我的zendstudio 创建． rm -rf *是不会删除隐藏文件的. linux rm hidden files rm -rf .*这个命令会过滤调. .. ,这两个目录是无法删除的. ubuntu 安装中文字体sudo apt-get install mysql-workbenchsudo apt-get install ttf-wqy-microhei sudo apt-get install ttf-wqy-zenhei ubuntu 16.04 默认启动命令行关闭sudo systemctl set-default multi-user.target启动lightdmsudo systemctl start lightdm恢复systemctl set-default graphical.target linux 权限管理# provided their password# (Note that later entries override this, so you might need to move# it further down)%sudo ALL=(ALL) ALLgroupadd sudosudo usermod -aG sudo work http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html 允许程序没有sudo权限执行sudo chmod +s /usr/sbin/hddtemp这样就可以让 hddtemp 在没有 sudo 权限的情况下运行了。 Linux 更新时间Linux 更新时间.主要的就是这个命令.ntpdate cn.pool.ntp.org好像 windows 时间 和 Linux 时间一定会又一个出问题.现在有点没有办法.将时间写入到 cmos 主要是系统时间写入 硬件时间 和 硬件时间写入系统的区别.sudo hwclock –systohcsudo hwclock –hctosys ubuntu 常用命令 命令 说明 apt-cache search ubuntu 在source里查找某个软件包 apt-cache install 安装指定的软件包 dpkg -i your.deb 安装一个deb文件 sudo dd if=/home/your.iso of=/dev/sdb 用U盘烧镜像 groups faith 查看faith的用户详情 ls | xargs rm -rf *这个命令比较调皮，markdown的表格里写不进去，单独拿出来伺候。删除文件，主要是xargs，可以将管道传过来的内容交给后面的命令，作为它的输入","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.nofile.cc/tags/ubuntu/"}],"keywords":[]},{"title":"javascript 学习笔记","slug":"note-js","date":"2016-09-09T06:39:00.000Z","updated":"2017-05-08T15:37:52.630Z","comments":true,"path":"posts/2016/09/09/note-js.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-js.html","excerpt":"","text":"jquery常识如果$() 的括号里面是一个dom元素的话，这个东西就是一个jquery对象。jquery 的方法，on ，可以绑定事件，each可以循环遍历数组。同时js自己的array也是一个对象，有foreach方法。要注意和jquery的each 方法区分。js 几个常用的事件keyup onchange click js 的闭包函数，这几天php中也用了不少，一个是array_walk, usort()有些场景中用这些函数是很方便的，这些函数都有自己适合的场景，要在合适场景使用,才能体现出这些函数的作用。 js 正则.正则表达式各种语言基本都是类似的，选择任一种实现都可以。^匹配开头$匹配结尾除了一些最基本的之外，可以简单思考下下面这些问题 贪婪匹配跨行匹配. 尽可能多的匹配.? 匹配到一个就可以了 js localstoragejs localStorage.localStorage.getItem();localStorage.setItem(); underscoreUnderscore提供了100多个函数,包括常用的: map, filter, invoke — 当然还有更多专业的辅助函数,如:函数绑定, JavaScript模板功能,创建快速索引, 强类型相等测试, 等等. 详细的文档可以参见这里。http://www.css88.com/doc/underscore/ ####jquery on 的代理实现 记得有这样一个场景。一个页面里面会使用到弹层，弹层上面有一些按钮，需要给这些按钮绑定事件。可以使用on方法绑定。但是在js代码执行的时候，这个坦层并没有出现，页面中并没有这个dom对象。这个时候，需要用到on的另一种使用方法。在他的父元素上绑定。parent.on(‘click’,’selector’,function(){})是一种类似这样的用法，当时这个解决了个很重要的问题。jquery 中给一个元素中追加一些属性可以用append方法来实现。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"},{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/tags/programming/"}],"keywords":[]},{"title":"Linux VPN 配置","slug":"note-vpn","date":"2016-08-29T06:43:00.000Z","updated":"2017-05-08T15:37:55.039Z","comments":true,"path":"posts/2016/08/29/note-vpn.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/29/note-vpn.html","excerpt":"","text":"ubuntu14.04 安装vpn这个是最正确的教程，没有之一。http://mad-scientist.us/juniper.html下面是一个简单的总结 sudo apt-get install libstdc++6:i386 lib32z1 lib32ncurses5 libxext6:i386 libxrender1:i386 libxtst6:i386 libxi6:i386sudo apt-get install openjdk-7-jre icedtea-7-plugin openjdk-7-jre:i386sudo apt-get install icedtea-pluginsudo apt-get install libc6-i386 lib32nss-mdnssudo apt-get install libgtk2-perl libwww-perlwget -q -O /tmp/msjnc https://raw.github.com/madscientist/msjnc/master/msjncchmod 755 /tmp/msjncsudo cp /tmp/msjnc /usr/bin http://www.scc.kit.edu/scc/net/juniper-vpn/linux/ 还可以参考这个帖子。需要得到realm这个东西，这个东西，去你公司的vpn网站爬一下就可以了。搜索一下realm这个字，就可以看到这个内容的值。最终推荐使用哪个客户端,比mac的客户端还好用。不过如果没有特别的爱好，还是用mac吧,折腾起来，还是有点麻烦的。","categories":[],"tags":[{"name":"vpn msjnc","slug":"vpn-msjnc","permalink":"https://blog.nofile.cc/tags/vpn-msjnc/"}],"keywords":[]},{"title":"C学习笔记","slug":"note-c","date":"2016-08-28T09:39:00.000Z","updated":"2017-05-08T15:38:16.281Z","comments":true,"path":"posts/2016/08/28/note-c.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/28/note-c.html","excerpt":"","text":"C文件的编译过程编译一个c文件，产生一个可执行文件，这个过程分为四个步骤 .c 文件到 .i 文件， --&gt; .s 文件 --&gt; .o 文件 --&gt; 可执行文件分别是预处理， 编译， 汇编， 链接 预处理所做的事情。 gcc -o helloworld.i helloworld.c -E 将 include 变成真实的东西 宏替换。 宏函数的优点。比一些函数要方便， 条件编译，对于程序的移植和调试，非常有用。 C语言中的宏 条件宏 #include &lt;iostream&gt; #include &quot;head.h&quot; #include &quot;head.h&quot; if you include &quot;head.h&quot; twice, you find you can compile your file as well.but if your head.h is writte without #ifndef, #define #endif, then you must will get an error to stop your working.also, here the use of, #ifdef #else #endif this condition definition can save your release code size :).what is different between static type and dynamic type.static type: know when program is in compile process.dynamic type: know only in the run process. For pointer type. 宏函数,宏可以实现一个函数的功能，这样可以减少函数调用的消耗。函数中可以有参数，宏的功能也比较强大，远远不止是定义一个常亮那么简单,线面是一个简单的例子。并且宏中也可以调用另一个宏，就像函数调用那样,但是必须保证顺序。 注意使用do-while的格式。这样会比较安全（可以避免在宏后面增加一个；而带来的语法问题）。 例如下面的代码 #define swap(a , b) \\ *(a) = (*(a)) ^ (*(b)); \\ *(b) = (*(a)) ^ (*(b)); \\ *(a) = (*(a)) ^ (*(b)); #define msort(a , n ) \\ do{ \\ for(int i = 0; i &lt; n; i++){ \\ for(int j =0 ; j &lt; i ;j++){ \\ if(a[i] &lt; a[j]) { \\ swap(a+i , a+j); \\ } \\ } \\ } \\ }while(0) C 指针(函数指针) int (*) p[10] 本质上是一个指针，指向一个有10个元素的数组。指针数组。 int * p[10] 本质上是一个数组，数组里面的每一个元素都是一个int*类型的指针。数组指针。 函数指针，函数指针可以作为一个普通的指针，既然它是一个指针，就可以通过参数来传递。下面是作为参数。可以参考下面的例子。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int (* funcType) (int); /*定义一个函数指针的类型*/int func (int); /*函数指针*/int func_test(funcType fp , int); /*用函数指针作为参数*/int func(int a)&#123; return a+1;&#125;int func_test(funcType fp , int a)&#123; return fp(a);&#125;int main()&#123; int abc = 100; /*定义一个函数指针，指向一个函数。函数名本质上是一个指针常量*/ funcType hello = func; int dd = (*hello)(abc); printf(\"value of variable dd is %d\\n\",dd); abc = func_test(func , abc); printf(\"%d\\n\",abc); return 0;&#125; C 中的extern关键字 让变量可以在其他文件中也可以使用。只能对全局变量起作用，不在全局作用域会导致编译报错。本质上是为了多个文件中共享变量，在工程中，可以让工程更好维护。 需要注意的是，c语言中的函数原型本身具有外部链接属性，所以对与函数而言，用不用extern都是一样的。所以呢，对于extern来说，用在变量上可能作用更大一些。在C语言中，extern变量的存在改变了变量的链接属性，用extern关键字修饰的变量其定义将在别处，编译器的变量解析将推迟到链接上。 一般来说，C工程的管理方式是将所有的外部函数定义在一个.h文件中。在需要用到这些函数的C文件中，包含这个.h文件就可以了。但是如果没有用.h 文件的话，这个时候就必须在主文件中用extern申明一下用到的函数了，但是这并不是必须的，没有这个extern也是可以的，所以extern对于函数来说，不是必须的，完全可以忽略，对于函数，作用不大。 函数可以申明多次，编译并不会报错，但是只能定义一次。 下面是一个具体的例子:里面函数申明前面的extern关键字都可以没有，函数默认有了这个属性。 /*** main.c ***/#include &lt;stdio.h&gt;#include \"b.h\"extern void print_hello(char *);const int TSM = 10000;int main()&#123; print_hello(\"hello world\"); return 0;&#125;/*** b.h ***/#ifndef B_H#define B_Hextern int print_hello(char *);#endif/*** b.c ***/#include &lt;stdio.h&gt;extern int TSM;void print_hello(char *s)&#123; printf(\"\\t\\t%s\\n\",s); printf(\"%d\\n\",TSM);&#125; 一些语言细节 malloc 和 calloc的区别。 malloc 可以分配内存，但是不做初始化。calloc也是分配内存，但是给你做初始化，新能比malloc差一点。但是在需要初始化的时候，用calloc可以省去memset的函数调用时间，看需求来定。注意malloc和calloc的参数的不同,malloc 只需要一个参数。realloc的使用,比如你给int *a分配了10个空间，现在发现10个不够了，那么你需要realloc以下。realloc的指针必须是没有free的。 使用math.h的时候，在编译的时候需要加上-lm 参数。 c语言的struct关键字，在定义节点的时候都需要带上，这一点和c++不同，需要注意。可以用typedef来简化这一点。typedef可以出现在结构体定义之前。","categories":[],"tags":[{"name":"c","slug":"c","permalink":"https://blog.nofile.cc/tags/c/"}],"keywords":[]},{"title":"vim 学习笔记","slug":"note-vim","date":"2016-08-28T06:43:00.000Z","updated":"2017-05-08T15:57:26.758Z","comments":true,"path":"posts/2016/08/28/note-vim.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/28/note-vim.html","excerpt":"","text":"vim的几个常用的插件 插件 说明 vim-ariline 彩色 的状态栏 nerdtree 一个文件管理器 gittur git集成插件,可以显示修改了的内容 bundle 插件管理 vim-markdown 支持markdown的语法 taglist 和ctags配合使用的，会在右边出现一列，展示所有的变量和函数。 常用的快捷键是这3个 ctrl + ] , ctrl + t ,ctrl + o ctags 安装比较简单sudo apt-get install ctags , 安装之后，进入代码目录，执行 ctags -R . cscope安装 sudo apt-get install cscope 下载就好 ，进入代码目录，执行 cscope -Rbkq执行这个命令后，会生成3个文件，cscope.in.out和cscope.po.out文件,cscope.out .然后配置vim ，将如下配置文件写入vimrc 。vim cscope file not found 用cscope的话，需要给vim中增加一个配置。set csre ,具体的可以:help csre 看一下。增加这个设置，可以让vim中的cscope真正能用起来。如果没有的话，在你找到了东西想跳转的时候，会提示没有这个文件的错误，这个在下面的配置中已经增加了。 set tags=tags; &quot;conf for ctagsset csre &quot;use absolute path in cscopeif filereadable(&quot;cscope.out&quot;) cs add cscope.out endifif has(&quot;cscope&quot;) set cscopetag &quot; 使支持用 Ctrl+] 和 Ctrl+t 快捷键在代码间跳来跳去 &quot; check cscope for definition of a symbol before checking ctags: &quot; set to 1 if you want the reverse search order. set csto=1 &quot; add any cscope database in current directory if filereadable(&quot;cscope.out&quot;) cs add cscope.out &quot; else add the database pointed to by environment variable elseif $CSCOPE_DB !=&quot;&quot; cs add $CSCOPE_DB endif &quot; show msg when any other cscope db added set cscopeverbose nmap &lt;C-S&gt; :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-G&gt; :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-C&gt; :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-T&gt; :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-E&gt; :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-Y&gt; :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt; nmap &lt;C-I&gt; :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt; nmap &lt;C-D&gt; :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;endifset autochdir 使用，在if语句里面，我们队cscope进行了快捷键映射，这样会方便我们使用。快捷键是Ctrl 和 字母的组合，例如Ctrl + S ，可以触发:cs find s + 光标所在位置的单词 这个命令。 其他的同理。在vim中忘记了我们设置的映射，可以用:map 来查看。关于vim 的key-binding，可以参考这篇文章，http://yyq123.blogspot.com/2010/12/vim-map.html。 :h key-notation可以查看键盘符号的详细说明。 vimscript下面是一些简单的vimscript内容。 vim 中定义变量要用let a=123 空格并不能影响效果，这一点和shell并不一样.echo a这样就可以看到效果。在 vimrc 中可以写简单函数，来做一些想做的事情，比如根据文件后缀，自动执行脚本程序。:echo % 这个是获得当前文件的全名，包括后缀的。:echo %&lt; 和下面的一行作用一样。:echo %:r 这个是获取当前文件的文件名，除去扩展后缀 插入模式下的 vim ， ctrl + j 可以将文本内容下移一行。ctrl + m 我也不知道具体是什么，我只是通过实验尝试出来的。 vim slowstartvim –startuptime vim.log -c qsudo vim 启动速度超级慢。vim 启动速度变慢.在终端中可以这样启动 vim -X 这样是不需要和X挂上勾的,所以会变慢.修改了一下之后瞬间感觉电脑变快了.vimariline这个插件会明显增加启动时间，加之没什么用，后面就从我的vim插件里面去掉了。 调查之后，发现是我把系统的hosts文件删除了，touch了一个空文件。后面，总是提示unresolve host 的提示。在增加了我的hostname在host中之后，sudo vim 速度就快了。开来和这个也有关系。 vim 常用操作 vim 记录上次编辑位置。加入这一行au BufReadPost * if line(&quot;&#39;\\&quot;&quot;) &gt; 0|if line(&quot;&#39;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &#39;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif到vimrc里面 vim 删除重复行 sort然后g/^\\(.\\+\\)$\\n\\1/d vim 插入当前时间,在vimrc中加入这个map，在normal模式下，输入,dt就可以在当前位置插入时间了map ,dt a&lt;C-R&gt;=strftime(&#39;%Y-%m-%d %H:%M&#39;)&lt;CR&gt;。 vim find 在vimrc中加入如下配置set path=/home/yourpath,在vim命令行中查找文件，有了这个配置之后，就会在这个目录下进行搜索。 vim 导入其他文件内容将当前文件的部分内容导入到其他文件1,20 w&gt;&gt; /path/otherfile.txt1,20 w /path/otherfile.txt具体命令就是这样。 同样的，也可以将其他文件的内容读入到当前文件来。命令是这个r: /path/file.txt 同时，这个命令也可以将外部程序的输出读入到当前文件中。r !date这样也是可以插入时间的。将这个命令用map命令映射一下，就可以得到和那个实现的同样的功能了。设置VIM为shell的默认编辑器export VISUAL=vimexport EDITOR=”$VISUAL” vim和系统共享剪切板首先需要补充的一点是，+寄存器是只有vim-gtk 或者 vim-gnome 才会有的，不要只安装了vim，这是不够的啦，在安装的时候需要注意一下，不然是无法使用系统剪切板的啦。复制单个字符， nyl n 是数字，l和vim的方向键一样，表示向后，就是向后复制n个字符。同理，nyh 表示向前复制n个字符。这样就可以很自由的复制了。复制单词 ynw 其中n是数字，表示要复制的单词的个数。按行为单位复制：nyy 表示复制n 行，和上面的命令差不多。应该是向下取的。p 表示粘贴，注意小写，这个是代表粘贴在下面。P 也表示粘贴，这次是大写啊，这个是代表粘贴在前面。估计对于字符复制粘贴的内容也是同样的规则啊。“+y 表示复制到系统剪切板去。这个应该忘不了吧。 vim 有很多的粘贴板，这些东西的用处你自己应该可以理解，一般情况下，都是只用一个粘贴板的，但是粘贴板多一点也是没有坏处的啊。vim中的复制是用y来完成的，在这之前，你当然可以决定你的内容是存放在那个粘贴办中，你可以用reg来查看这些粘贴板中都存了什么内容，同时p是用来复制的，你也可以在复制之前决定你从哪个粘贴板中复制内容，例如”4p表示是从4好粘贴板中拿东西。如果4好粘贴板中有你存下的内容的话，那么他就可以复制出来了，结合上面的命令，你当然可以做成你想做的。复制到第n 个粘贴板的命令: 先选择要复制的内容，然后”ny 就可以将这些内容放到粘贴板了。然后在你想复制的地方”+p 就可以了。","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://blog.nofile.cc/tags/vim/"},{"name":"cscope","slug":"cscope","permalink":"https://blog.nofile.cc/tags/cscope/"},{"name":"ctags","slug":"ctags","permalink":"https://blog.nofile.cc/tags/ctags/"}],"keywords":[]},{"title":"nginx 学习笔记","slug":"note-ng","date":"2016-08-26T06:41:00.000Z","updated":"2017-05-08T15:38:04.062Z","comments":true,"path":"posts/2016/08/26/note-ng.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-ng.html","excerpt":"","text":"nginx编译参数sudo apt-get install libpcre3sudo apt-get install libpcre++-devsudo apt-get install libgd-dev./configure \\ --prefix=/home/service/nginx \\ --with-http_ssl_module \\ --with-http_realip_module \\ --with-http_addition_module \\ --with-http_xslt_module \\ --with-http_image_filter_module \\ --with-http_sub_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_mp4_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_auth_request_module \\ --with-http_random_index_module \\ --with-http_secure_link_module \\ --with-http_degradation_module \\ --with-http_stub_status_module \\ --with-pcre \\ --with-zlib=../zlib-1.2.8 \\ --with-openssl=../openssl-OpenSSL_1_0_2d \\ 编译过程中容易遇到的问题。 前面三行是安装configure参数中需要依赖的内容，先安装可以保证configure可以通过。openssl比较容易出问题，需要openssl的源码包。编译之前貌似会先编译openssl，要保证openssl可以编译。先要在openssl的目录，./config 一下。然后make depend，然后再进入nginx的源码目录进行make。需要依赖一些其他的东西，zlib是必须的，要下载源码包。 nginx 配置规则这部分有待深入研究，暂时先留着。 location 写法。 log_format 配置中添加自定义参数 fastcgi_params define_params hhh nginx 启动和重启操作之前先确认下配置文件的正确性。nginx -t -c /usr/nginx/conf/nginx.conf#启动 停止 或者重启 nginx 。nginx -s reload nginx #重新加载配置文件pkill nginx #停止nginx","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[]},{"title":"PHP 学习笔记","slug":"note-php","date":"2016-08-26T06:41:00.000Z","updated":"2017-05-08T15:37:58.632Z","comments":true,"path":"posts/2016/08/26/note-php.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-php.html","excerpt":"","text":"PHP 回掉函数的使用。这是最基本的回掉方法。call_user_func_array(‘your function’,array());array() is your params. 刚才在文档里发现了好多东西，原来还是要自己编译才是最好的。才能够了解更多的特性。./configure –help其实已经包含了很多信息，只是你还不了解。要编译安装，这个是很重要的一步。 编译php常见的20个错误。http://crybit.com/20-common-php-compilation-errors-and-fix-unix/ PHP 扩展安装 PECLPECL is a repository for PHP Extensions, providing a directory of all known extensionsand hosting facilities for downloading and development of PHP extensions.PECL is very important. PHP 断言的使用。需要进行一些基本都的设置才可以。 assert_options(ASSERT_ACTIVE, 1);assert_options(ASSERT_BAIL, 1);$a = 'i1.23';assert(is_numeric($a));echo $a; PHP 正则表达式.preg_match 有几个关键词需要注意,一个是界定符 # / 这个可以自己设置的.preg_match 如果判断整个字符串的话,就要断言. 用 ^$.可以带 result 参数，将匹配的内容都放在这个result数组中。这个数组的参数应该是应用类型的。说到引用类型，我对这个还不是太清楚，没怎么使用过，应该熟悉一下。类似的函数还有 preg_match_all() , 返回值表示是否匹配.$name = \"hello\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'sas\";var_dump($name);$new_name = preg_replace(\"/\\\\\\*/\",\"\",$name);var_dump($name);var_dump($new_name); PHP urlencode, urldecode, rawurlencode, rawurldecode他们之间的差别还是比较小的,差别就是对+号的处理,我建议使用 rawurldecode, 而不是urldecode. 但这个改动不可以贸然,可能一起bug.在最初的时候设计的时候,就要考虑这一点. curl 参数curl 带json参数,需要加上-d 参数.没有这个参数是无法访问的.curl -d {goods_id:123123} “http://sss.ss.xx“ PHP array系列函数下面这个函数里面包含两种用法，一种是array_walk(), 还有一种是 变量的引用。这个和c语言是很相似的。$test = [1,2,3,5];array_walk($test , function(&amp;$i) &#123; $i++; &#125;);var_dump($test); PHP魔术方法__construct() 构造方法,生命类对象的时候就会调用.__desctruct() 析构方法,在类对象的生命周期结束之后. 这个和垃圾回收有什么关系吗.__call() must be public method.__callStatic() for static class method.__autoload().get_called_class() 一般是在基类中用到.基础类库中用这个方法.get_class(). 得到当前类的名称.static::class 和上面的得到同样的结果.PHP_EOL. 提高代码的可移植性. 换行符. mac windows, linux 下是不一样的.user_call_func() 这个方法是写自定义函数,利用这个方法,调用的函数会变成一个变量,所以非常灵活.user_call_func_array() 和上面的额方法类似,区别在于这里的方法的参数是数组.这些东西被统称为魔术常亮.__METHOD__ return the name of the function alongwith the class name.__FUNCTION__ just return the name of the function.__CLASS____FILE__ return filename of current file.__LINE__ return current line number.__DIR__ equal dirname(__FILE__). PHP SPL 方法 STANDARD PHP LIBRARYPHP 中spl 开头的一些方法是做什么的,比如spl_autoload_register.类似的方法还有不少,都是用来做什么的额.刚才调查了一下,确实有好多东西,这些都是PHP的高级语法,应该认真研究下,用好了,可以写出高效的代码. 对这门语言,我的了解还是不够,还需要认真研究.PHP SPL ==&gt; standard PHP library. PHP XHPROFXHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。一个函数的开销，可细分成调用者和被调用者的开销，XHProf数据收集阶段，它记录调用次数的追踪和包容性的指标弧在动态callgraph的一个程序。它独有的数据计算的报告/后处理阶段。在数据收集时，XHProfd通过检测循环来处理递归的函数调用，并通过给递归调用中每个深度的调用一个有用的命名来避开死循环。XHProf分析报告有助于理解被执行的代码的结构，它有一个简单的HTML的用户界面（ PHP写成的）。基于浏览器的性能分析用户界面能更容易查看，或是与同行们分享成果。也能绘制调用关系图。 PHP composerhttp://pkg.phpcomposer.com/ PHP 图像操作session_start();header(\"Content-type:image/png\"); $img_width=100;$img_height=20;srand(microtime()*100000);for($i=0;$i&lt;4;$i++)&#123; $new_number.=dechex(rand(0,15));&#125;$_SESSION[check_auth]=$new_number;$new_number=imageCreate($img_width,$img_height);//创建图象ImageColorAllocate($new_number,255,255,255); //设置背景色为白色for($i=0;$i&lt;strlen($_SESSION[check_auth]);$i++)&#123; $font=mt_rand(3,5); $x=mt_rand(1,8) + $img_width*$i/4; $y=mt_rand(1,$img_height/4); $color=imageColorAllocate($new_number,mt_rand(0,100),mt_rand(0,150),mt_rand(0,200));//设置字符颜色 imageString($new_number,$font,$x,$y,$_SESSION[check_auth][$i],$color);//输出字符&#125;ImagePng($new_number);ImageDestroy($new_number); PHP echo 和 print的区别。主要掌握echo的下面这两个特性。print更多的是一个函数。 echo \"hello\", \"world\";echo &lt;&lt;&lt;EOTtestEOT; PHP session 和 cookiePHP配置中介绍了session和cookie相关的配置。注意PHPSESSID这个东西,这个是通过session.name = PHPSESSID 来设置的。但是如果同一个server上部署了2个应用，那么两个应用的session.name都是相同的。不知道会不会有影响。完了我会测试一下。这个貌似不会相互影响。cookie会存放在不同的域名下面的。 PHP 配置那天发现我本地环境速度很慢的原因是 php-fpm.conf 中的maxchildren 数量太少了。我改成static 的，然后把最大数量变成128； 一下子就不用排队了。当时的现象是这样的。我看network，显示网络请求在排队，但是我完了单独访问每一个排队排了很久的接口，速度都很快，所以很疑惑。 PHP memcache 扩展和 memcached扩展memcache扩展比memcached扩展要早，但是功能上不如后者，memcache基本上只支持set和get。memcached可以支持更多方法。一般建议安装memcahced扩展。安装memcached扩展时需要安装libmemcached，memcache扩展则不需要。 PHP $_SERVER 变量PHP在命令行模式下的$_SERVER变量中的变量可以在shell中export来设置,shell中的变量会出现在SERVER变量中。在web环境中,要通过在服务器中设置才可以。nginx在fastcgi_params中设置。 session的相关配置。 session.save_handler = filessession.save_path = /tmpsession.use_cookies = 1session.use_only_cookies = 1session.name = PHPSESSIDsession.auto_start = 0session.cookie_lifetime = 0session.cookie_path = /session.cookie_domain =session.cookie_httponly =session.serialize_handler = phpsession.gc_probability = 1session.gc_divisor = 1000session.gc_maxlifetime = 1440session.bug_compat_42 = Offsession.bug_compat_warn = Offsession.referer_check =session.entropy_length = 0session.cache_limiter = nocachesession.cache_expire = 180#通过url传值，而不是cookiesession.use_trans_sid = 0session.hash_function = 0session.hash_bits_per_character = 5 PHP 开启slowlogPHP 异常","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"},{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"}],"keywords":[]},{"title":"Python 学习笔记","slug":"note-python","date":"2016-08-26T06:39:00.000Z","updated":"2017-05-08T15:38:12.708Z","comments":true,"path":"posts/2016/08/26/note-python.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-python.html","excerpt":"","text":"Python 内置函数__call__ __getattr__这两个内置函数是非常有用的,首先这两个函数是可以给类定义的.只有在class中才能实现这两个函数.__call__ 这个方法,可以让对象的实例作为一个无名函数被使用.实际上是给class重定义了()运算符. 每次通过实例访问属性,都要经过 __getattributge__() 如果属性没有定义,还需要访问 __get_attr__() __getitem__, __setitem__, __delitem__ 这几个方法比较容易理解,就是对一个类的实例,可以按照下标的方式进行访问. 无需过多解释. 参考资料 http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html ####创建一个类的静态方法, def A(object):@staticmethoddef hello(): return \"hello world\"def world(self): return \"class instance method\" ####静态方法 class A(object):@classmethoddef foo(cls): print 'class name is',cls.__name__def python REGULAR EXPRESSIOn正则中的正向引用的问题，其实还是有一定的问题的。我发现下面的引用并不能成功,不知道是为什么。所以只能放弃\\1的写法，重复写前面的那个。期望可以匹配出字符串中的日期。这个正向引用的问题，希望以后可以有机会解决。 regex= r\"[\\d]&#123;4&#125;(-)[\\d]&#123;1,2&#125;\\1[\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str)str = ['nasdfasfd2015-12-31' , 'asdlasdff2015-12-11']regex= r\"[\\d]&#123;4&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str) file 你不知到的。 如果脚本是以相对路径被执行的，返回的是“” ， 并不会返回脚本当前目录。只有脚本是以绝对路径执行的时候，才会有对应的目录，这个问题需要注意。 shutil 可以操作文件目录，包括复制，移动，删除。比较常用。os.getcwd() 可以替代 os.path.dirname(file) , 这种方式有时候不如前者可靠。 python 变量不定义之前就使用是会报错的。 我发现上面的说法并不一定正确,getcwd 这个东西要小心使用,应该认真阅读一下这个方法的文档.它可能并不适用你的场景.在本质上,我需要的事这个东西. Python 获取当前脚本文件路径目录# -*- coding: cp936 -*-import sys,os#获取脚本文件的当前路径def cur_file_dir():#获取脚本路径 path = sys.path[0] #判断为脚本文件还是py2exe编译后的文件，如果是脚本文件，则返回的是脚本的目录，如果是py2exe编译后的文件，则返回的是编译后的文件路径 if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path) #打印结果print cur_file_dir() python excel 操作.完成了一个python 导入到处数据的功能.用到了这两个module xlwt, xlrd . 这个仅支持 xls 类型的excel. xlsx部支持.首先是安装 pip . sudo apt-get install python-devsudo apt-get install libmysqlclient-devsudo apt-get install python-pippip install mysql-pythonpip install xlwt pip install xlrd 数据库操作记得 commit .插入数据和写入数据的时候注意 转义.python MySQLdb 也可以绑定变量,这样可以不用关心特殊字符. 类似PHP. 全局变量的引用,应该使用global字段.python 从数据库中取出中文内容乱码.unicode 需要decode成utf8 的才可以,还需要其他的设置,完了需要一一验证. 下面是示例代码: 今天想到了python的爬虫框架。刚才查了一下，发现了scrappy这个东西。后面要找时间了解一下。http://www.jianshu.com/p/078ad2067419 python2.7的字符编码问题unicodedecodeerror: 'ascii' codec can't decode byte 0xef in position 0: ordinal not in range(128)import syssys.reload()sys.setdefaultencoding(\"utf-8\")","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://blog.nofile.cc/tags/python/"}],"keywords":[]},{"title":"PHP 与 FPM 的区别","slug":"note-phpfpm","date":"2016-08-25T15:47:00.000Z","updated":"2017-05-08T15:38:15.093Z","comments":true,"path":"posts/2016/08/25/note-phpfpm.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/25/note-phpfpm.html","excerpt":"","text":"PHP与FPM的区别nginx , fastcgi , php-fpm , php-cgi , cgi , php.ini , master process , work process , php kernel.这个问答写得很好,推荐参考。 首先nginx处理不了php这类的脚本程序，只能扔给php去做。最早的时候，php并没有php-fpm这个东西，后面php把fpm收进了内核，编译的时候，只需要enablefpm就可以了。php-fpm是一个实现了fastcgi的程序，后来被php收了。cgi 是一个协议，php-fpm 实现了这个协议。就可以和nginx通信了。cgi 的全写，common gateway interface 。为了保证web server 传递过来的参数都是标准格式的，方便cgi程序的编写，本质上是一个标准。 web server（比如说nginx）只是内容的分发者。比如，如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。 当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。 php-cgi 是php的解释器 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。 fastcgi是cgi的改进版，cgi每次都需要解析php.ini，这样做效率很低，后面就有了fastcgi，它有一个master进程，只有master进程中会load php.ini，然后后面有请求都只会fork一个child process去处理。可以实现平滑重启。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"},{"name":"php-fpm","slug":"php-fpm","permalink":"https://blog.nofile.cc/tags/php-fpm/"},{"name":"fastcgi","slug":"fastcgi","permalink":"https://blog.nofile.cc/tags/fastcgi/"}],"keywords":[]},{"title":"leetcode 刷题笔记","slug":"note-leetcode","date":"2016-08-25T06:40:00.000Z","updated":"2017-05-08T15:38:19.835Z","comments":true,"path":"posts/2016/08/25/note-leetcode.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/25/note-leetcode.html","excerpt":"","text":"LEETCODE 学习笔记https://leetcode.com/ 可以按照分类做题。可以先做自己感兴趣的，easy 的 货这medium 的。hard的等最后了再做。不管怎么样的题目，对于一个搞代码的来说，做一下都是很有好处的，我觉着算法练习就好比是武侠世界中的内功，多多益善，勤于练习总是会有好处的。目前做了40个题目，做得比较少，做的题目中等的偏多一点，后面会继续做，作为业余爱好吧。不然业余时间还真没什么事做。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"}],"keywords":[]},{"title":"mysql笔记","slug":"note-mysql","date":"2016-08-24T06:40:00.000Z","updated":"2017-05-08T15:38:01.681Z","comments":true,"path":"posts/2016/08/24/note-mysql.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/24/note-mysql.html","excerpt":"","text":"Mysql 基本知识 Mysqlslap 自带的性能测试工具. 一些mysql基本的操作 show global variables like '%%datadir%' //看MySql数据库物理文件存放位置show variables like 'innodb_data%';set autocommit = 0lock table file_text writeunlock tablescreate table newtable select * from oldtable;INSERT INTO newTable SELECT * FROM oldTable;INSERT INTO newTable (col1,col2,…….) SELECT col1,col2,…… FROM old_tableinsert into myblog (id,title,ctime) values(123,'hello',now()) on duplicate key update title=values(title),ctime=values(ctime);//将 blog_bak 表中的所有数据导入到myblog 中，表 blog 和 blog_bak 应该有同样的表结构insert into myblog( blog,ctime) select * from blog_bak;if(tb2.shop_click is null, 0,tb2.shop_click) // mysql ifupdate table_a a , table_b b set a.shop_status = b.group_status where a.shop_id = b.shop_id; //这样可以将 table_b 的 状态同步到 table_a, 本质上和 多表查询是类似的。select * from xxx where id in (3,1,5) order by find_in_set(id,'3,1,5') order by substring_index和order by find_in_set都可以//select 按指定顺序排 mysql 单机启动多个实例 mysql_safe 和 mysql 的区别 Mysql 锁 MysIsma, Memory 支持表锁。Innodb 支持表锁和行锁,默认是行锁。 BerkelyDB 支持页锁,页锁的粒度和成本在表锁和行锁之间,不知道是什么鬼。 乐观锁可以通过增加一个version来实现。在提交的时候，带着version作为条件去更新，如果发现version不一致了，那么就不更新，如果和当时读取到的version一直才更新数据。 悲观锁的介绍，用到了select for update。要实现悲观锁，必须将数据库的autocommit属性置成0select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。select for update，现在使用select for update来查询数据，以达到排他读的目的。但是发现，在有正常结果数据时造成的锁表对系统性能有明显地影响。select for update的条件不是主键所以id，所以造成锁表。尽可能让所有数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定。 读锁和写锁 共享锁(S锁)又称读锁,若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S 锁.这保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改. 排他锁(X锁)又称写锁.若事务T对数据对象A加上X锁,事务T可以读A也可以修改A,其他事务不能再对A加任何锁,直到T释放A上的锁.这保证了其他事务在T释放A上的锁之前不能再读取和修改A. 并发事务处理带来的问题相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 Mysql 索引Mysql 索引 每次查询只能使用一个索引，所以如果在字段比较多的查询中，就算每个字段都创建了索引，也只能使用一个。但是如果创建了复合索引，这样能够走索引的内容就多了，效率会更高，所以复合索引的使用也很重要，是sql优化的一个很关键的点。 http://tech.meituan.com/mysql-index.html现在只会创建单索引,但是很多情况下,复合索引更有效. 一个表只能使用一个索引,如果单键索引和复合索引都会生效,那么mysql会选择哪个索引。mysql索引的最左选择的原则。 Mysql 优化器。在有很多个索引的情况下，mysql优化器会选择一个比较好的索引。可以利用mysql索引的运算符。索引可用于&lt;、&lt;=、=、&gt;=、&gt; 和BETWEEN运算。在模式具有一个直接量前缀时，索引也用于 LIKE 运算。 有些情况下,优化的作用是很有限的,最好还是不要写太复杂的sql. 但是有一个情景,就是需要更具字表的条件去筛选结果,做分页,这种情况如何处理，可以内存排序.让排序在mysql中排序比较困难.那么这个分页逻辑如何处理. Mysql join之后的索引使用情况是怎么样的，索引可以减少join语句的总共需要扫描的行数，提高join查询的效率。join的时候有个原则就是小标join大表。如果 不会选择，可以不指定join，让mysql自己去选择。order by 的字段是否有必要增加一个索引,如果有必要,是不是所有需要排序的字段都需要增加上索引?这个明显是不可取的。每个query只能利用一个索引,如果where种的字段用到了索引，并且where中的query和order by的字段不是一个，那么只能选择其中的一个索引，所以在一个quer中创建多个单键索引是没有意义的。 索引是在数据库表或者视图上创建的对象，目的是为了加快对表或视图的查询的速度。按照存储方式分为：聚集与非聚集索引; explain 显示mysql如何处理select语句以及连接表,可以帮助写出更好的查询语句和建立更好的索引。rows 表示mysql执行查询的行数,数值越大说明效果越不好,说明没有用好索引.using where :要想使查询尽可能的快, 应尽可能得找出 using filesort , using temporary 的extra的值.我觉这在业务重没有必要禁止连表查询，在不会带来什么压力的情况下，并没有什么必要。如果两个表，都比较简单，连表也没什么不可以。什么事情都应该分开来看待，没有什么是绝对的。 Mysql 复合索引符合索引的表现效率和索引顺序是密切相关的。创建复合索引的时候要仔细考虑顺序。符合索引上是可以增加排序的，查询中的排序必须和索引中的排序一直或者相反才可以用到索引。符合索引引只有一棵树，如果是a,b,c的索引，那么先a，后b，再c，如果a相等，则按照b的顺序排，如果ab都相等，那么按照c的书序排。查找的时候，如果是a，b，c三个都能用到索引的情况，会先按照a确定出一个大概范围，然后在用b来进一步缩小范围，再用c来最后确定查找范围。但是符合索引的顺序怎么设置比较好呢，我觉着这个应该由具体的业务决定。 阻止复合索引使用的情况 范围查找会中断符合索引。 使用计算函数无法使用索引。 &lt;&gt; !=无法使用索引。 CREATE INDEX idx_example ON table1 (col1 ASC, col2 DESC, col3 ASC) Mysql 翻页的方式不要以为翻页只有简单的limit。limit是最简单直接的方法，但是他的缺点也很明显，对于销量数据，千级别的，用这个来翻页取数据还勉强可以，但是如果数据量更大，那么久会很慢。这个时候只能采取其他的方式来设计。所以，对于limit的方式，最好做一个限制数量的翻页，不要做成无限制的翻页。具体参见这个mysql翻页 mysql 中创建用户。CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 如果是当前登陆用户 more detailed info see this link. http://www.jb51.net/article/31850.htm mysql 中的数据类型 基础数据类型 tinyint 1 字节 -128 ~ 128 smallint 2 字节 -32768 ~ 32767 mediumint 3字节 int 4字节 int(11) bigint 8字节 unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615 mysql decimal 对于精度比较高的东西，比如money，我会用decimal类型，不会考虑float,double,因为他们容易产生误差，numeric和decimal同义，numeric将自动转成decimal。DECIMAL从MySQL 5.1引入，列的声明语法是DECIMAL(M,D)。在MySQL 5.1中，参量的取值范围如下：·M是数字的最大数（精度）。其范围为1～65（在较旧的MySQL版本中，允许的范围是1～254），M 的默认值是10。·D是小数点右侧数字的数目（标度）。其范围是0～30，但不得超过M。说明：float占4个字节，double占8个字节，decimail(M,D)占M+2个字节。关于decimal范围的判断，下面这是一个不错的解释。 Although the answers above seems correct, just a simple explanation to give you an idea of how it works. Suppose that your column is set to be DECIMAL(13,4). This means that the column will have a total size of 13 digits where 4 of these will be used for precision representation. So, in summary, for that column you would have a max value of: 999999999,9999 引申 为什么floa 和 double 会丢失精度。1 字节 = 8 bit。 int 一般认为是32位。最长是10位。float 为4byte。double 为8btye。IEEE 754 标准，数的存法。 datetime 和 timestamp 的区别。 ctime datetime =&gt; now() 4字节 mtime timestamp ==&gt; CURRENT_TIMESTAMP 8字节 1970 ~ 2037 alter table user add column mtime timestamp not null default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP; alter table user add column ctime timestamp not null default CURRENT_TIMESTAMP; 1970 1.1 00:00:00 标准时间，一般情况，mysql需要2个字段，一个是ctime，一个是mtime，mysql中这两个字段一般都是not null 的，timestamp如果是2个默认值都是CURRENT_TIMESTAMP的话，sql会报错，可以像上面那样写。 Mysql 索引操作 mysqldump 数据导出和数据恢复create index index_name on table_name (column_list);alter table table_name add index index_name (column_list);对应的，删除索引。drop index index_name on table;alter table table_name drop index index_name;清空表中的数据，包括 auto_increment 的字段都会被重置。truncate table_name;mysqldump -h localhost -ppasswd -uroot -d database &gt; dump.sql ; // 只导出数据库的结构mysqldump -h localhost -ppasswd -uroot database &gt; dump.sql ; // 导出数据库的结构和所有的数据mysqldump -h localhost -ppasswd -uroot -d database tablename &gt; dump.sql ; // 只导出表结构mysqldump -h localhost -ppasswd -uroot database tablename &gt; dump.sql ; // 导出表结构和表中的数据mysql -u root -p yourpasswd -h localhost yourdb &lt; dump.sql // 将dump.sql 导出入到你的数据库 mysql 中的test 表的使用方法。如果你在数据表中没有数据的到处权限，但是一般的数据库中，test库中的权限你都是有的，所有可以将需要的数据先导入到test中的临时表中，然后再从临时表中导出去。这样可以绕开权限控制，到处你需要的数据。sql如下create table xxx as select * from you_target_table where xxx=xxx;这样 一张 test 中的临时表就创建好了，你可以用mysqldump将这个表中的数据导出去。 mysql时间处理函数select date_format(now(),\"%Y-%m-%d %H:%i:%s\") now;select date_sub(now(), interval 10 day) as yesterday; // 请不要吧 day 写成 days ，month , hour 同理。group by 多个字段 从 col_a -&gt; col_b -&gt; col_c 优先级依次降低。select * from test_table where status = 1 order by col_a desc, col_b desc, col_c asc limit 100;set @a = 100;select @a:=300; #可以通过 select 给变量赋值,这个变量只在这个链接周期中有效。 mysql 存储过程下面是一个简单的存储过程的例子。 delimiter $ # 因为 mysql 默认的 终止符是; 而这个正好是存储过程的语法，所以在编写存储过程之前，先将 delimiter 改成 $create procedure p() # 创建存储过程beginselect * from ttt;end;$delimiter ; # 将 delimiter 改成默认的; 这样符合我们的习惯call p(); # 调用这个存储过程","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.nofile.cc/tags/mysql/"},{"name":"存储","slug":"存储","permalink":"https://blog.nofile.cc/tags/存储/"}],"keywords":[]},{"title":"mac 开发环境搭建","slug":"note-mac","date":"2016-08-23T06:40:00.000Z","updated":"2017-05-08T15:38:00.088Z","comments":true,"path":"posts/2016/08/23/note-mac.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/23/note-mac.html","excerpt":"","text":"mac中让vim共享剪切板安装vim 默认情况下，mac terminal中是带了vim 的。但是vim –version 看一下，发现是7.3版本的。这个版本的vim，和mac系统的clipboard交互有点困难。如果想将vim中的内容复制出来的话，会有点麻烦，这又是一个很常用的操作，所以很麻烦。查资料可以知道，7.4的vim可以支持。所以我们通过安装7.4版本的vim来解决这个问题。安装方式如下： brew install vim -clipboard -xterm_clipboard --with-client-server#上面的命令不能成功，出一个很奇怪的错误，所以就没有太纠结。brew install vim --override-system-vim#通过提示可以知道，安装后的vim在下面这这个路径,我们可以通过一个简单的alias搞定。alias v='/usr/local/Cellar/vim/7.4.2152/bin/vim' 然后再试一下，发现不管是terminal中的vim，还是tmux中都可以看到*寄存器了。有了这个寄存器，就说明我们的vim剪切板可以和clipboard之间交互了。 vim backspace不能删除内容的解决方案 可以通过增加配置来解决。 set nocompatibleset backspace=indent,eol,start mac 中编译安装php nginx编译的过程中，很可能遇到这个问题。找不到openssl的header files。其实解决办法就是安装openssl。brew install openssl 。 但是只是安装了也可能报这个错误。找到了下面这个帖子。来自 stackoverflow。核心的是这个 brew install opensslbrew link openssl –force 遇到其他的报错，卡主了 confiture ，基本上用brew 安装那个就可以过关了。configure 过了之后，就可以make &amp;&amp; make install 了。 If you are on Mac OS X El Capitan, Apple doesn&apos;t include openssl any more because of security problems openssl had, I have similar problem installing Passenger. brew just installs openssl itself without development headers.If you are on an older version of Mac OS X than El Capitan, you can use: xcode-select --install which installs openssl development headers as well.EDIT:Updating brew and installing openssl and force linking openssl to brew version solved my problem:$ brew update $ which openssl /usr/bin/openssl $ brew install openssl$ brew link openssl --force $ which openssl /usr/local/bin/openssl mac 上虚拟linux一般来说，mac和linux已经非常像了，但是有些工作(比如，搭建服务器环境，编译nginx，php什么的，在linux下会方便很多，再比如要搞php源码，学学扩展开发什么的)，还是建议在linux下搞。所以在mac上，我们仍然需要一个linux。想到了virtualbox。 virtualbox的使用。mac的retina屏幕，导致在上面安装ubuntu桌面之后，分辨率很是难用，所以想要和之前一样使用linux的话就比较困难了，在retina屏幕上看见超低分辨率还是难以接受的。但是考虑到我们的日常，基本都是在terminal里面度过，所以我们完全可以放弃linux桌面，用mac的terminal ssh 到我们的虚拟机就可以了。需要解决的问题就是网络问题。让主机和虚拟机在同一个网段，这样就可以互相ssh了。更改virtualbox的网络设置，把默认的NAT方式换成birdge方式，并且在高级选项里面选成allow all。重启虚拟机，看一下ip，发现和主机在同一个网段了，然后就可以ssh进去，愉快的玩耍了。 有了这个方案之后，我们可以利用虚拟机做一些集群相关的实验，只需要多安装几个虚拟机就可以了，同样的方法。不过貌似virtualbox的网络adaptor最多只有4个，不过4个应该也足够了。","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"},{"name":"mac","slug":"mac","permalink":"https://blog.nofile.cc/tags/mac/"}],"keywords":[]},{"title":"Laravel 学习笔记","slug":"note-laravel","date":"2016-08-22T16:41:00.000Z","updated":"2017-05-08T15:38:13.885Z","comments":true,"path":"posts/2016/08/23/note-laravel.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/23/note-laravel.html","excerpt":"","text":"视图在laravel中，controller和view都不可避免的要使用多级目录，controller中使用多级目录的时候，要注意在路由中的写法。在路由中的写法Route::get(&quot;/test&quot;,&#39;Test/TestController@index&#39;),要设置resource，view中的多级目录，在controller中对应的目录结构的写法应该这样的return view(test.test.test)。laravel也用了namespace，这些和其他的框架基本都是一致的。 laravel phphub5时间笔记laravel 的这个错误，可以在这里找到答案。 http://stackoverflow.com/questions/31512970/laravel-no-supported-encrypter-found-the-cipher-and-or-key-length-are-invalid php artisan key:generate 因为用mac,开发环境我是自己配置的,大概包括下面这些内容,nginx(1.9) ， mysql(5.5.3) ， php(5.6) ,redis(3.2) 都是自己装好了的，版本都是比较新的,应该满足需要。还有就是安装composer，之前对这个不怎么了解，但是最近学习laravel，发现这个东西真是太好了，不知道composer只能说明你比较古董，还在几年前的php开发水平上，新技术里没有这个是谈不上高效的，因为好多东西大家都已经写好了，并且都相当稳定了，你再自己去找其他的，就比较没效率了吧,所以composer也是我们的必不可少的。node相关的环境，需要下面这些，node ，npm ，cnpm ,cnpm ,gulp 的安装最好使用alias的那种命令，最好再有nvm，方便安装node。 我本地安装了4.5的node,有了nvm之后，node的版本都是随便选择，随便切换，很方便的。 首先clone phphub5 的官方包。 composer install --prefer-distcnpm install 最好能顺便了解一下package.json , gulp , gulpfile.js这些东西，现在是学习使用，后面可能需要自己开发。cnpm init 可以生成自己的package.json，但是这个只是生成的一个默认的，内容还需要自己扩展进去。通过上面的composer install，安装好了项目依赖的所有的php的扩展包。cnpm install安装好了前端需要的扩展包。这样，项目依赖的内容基本上就ok了，然后配置基本的配置文件。将.env.enviroment 该成 .env 然后将对应的内容修改成自己的db配置。记得打开 config/app.php 的调试信息，这样可以自己方便找出错误。然后在确认下config/database.php 中mysql的配置。和自己本地的db一致就可以了。最后需要修改storage目录的权限，可以 sudo chown www:www -R storage 修改用户组就可以了。改成nginx配置文件中的那个用户组和用户，我的配置里面的是www.www 。通过上面的这些工作，基本上我们的phphub基本上就运行起来了。然后可以根据自己的需求进行定制了。 感觉最近学西最大的收获就是这个项目了，虽然还没有详细研究，但是一个简单的入门，就让我了解到了laravel的高效，之前得开发是效率低并且质量差，并且水平低。这才是正确的做法。当你想做一个产品时，并不是让你从头开始做，你应该对自己所在的领域足够了解，知道有哪些东西已经有了，哪些东西没有，我相信能做好这个判断，会给你的项目节省不少成本，我觉着，这个才是一个技术leader最应该做的事情。","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://blog.nofile.cc/tags/laravel/"}],"keywords":[]},{"title":"382. Linked List Random Node","slug":"ag-382","date":"2016-08-20T11:07:00.000Z","updated":"2017-05-08T15:37:42.375Z","comments":true,"path":"posts/2016/08/20/ag-382.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-382.html","excerpt":"","text":"382. Linked List Random NodeGiven a singly linked list, return a random node&apos;s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 分析这个题目的做法其实很简单。最开始先选择第一个元素，然后一直往后那，到第k个元素，以1/k的概率用这个元素替换已经选中的元素。可以证明每个元素被选中的概率都是1/n。算法最核心就是以1/k的概率替换选中的元素。这个可以利用rand函数就可以实现。因为cnt从0开始，所以拿参0来做参考值。下面是证明过程。第k个元素最终被选择的概率=第k个元素被选择*并且在后面的选择过程中没有被替换的概率=1/k*(1-1/(k+1))*(1-1/(k+2))...*(1-(1/n))=1/n。这就可以表明，算法中的每个元素被选择的概率都是1/n 看了下同类的题解，都说到了这个蓄水池抽样,这篇文章写的不错，里面有详细的分析和证明，大家可以参考下，我就不再这里重复了，最主要的是自己能够计算证明一下概率的计算。 代码import randomclass Solution(object): def __init__(self, head): self.head = head def getRandom(self): tmp = self.head cnt = 0 ans = None while tmp: if random.randint(0,cnt) == 0: ans = tmp tmp = tmp.next cnt += 1 return ans.val class ListNode(object): def __init__(self , val): self.val = val self.next = Nonedef genList(head): prev = head for i in range(0,5): tmp = ListNode(i) tmp.val = i tmp.next = None if i == 0: head = tmp prev = tmp else: prev.next = tmp prev = tmp return headdef printList(head): tmp = head while tmp: print tmp.val, tmp = tmp.next passif __name__=='__main__': head = ListNode(-1) nh = genList(head) mapp = dict() for i in range(0,5): mapp[i] = 0 obj = Solution(nh) for i in range(0,100000): val = obj.getRandom() mapp[val]+=1 for k in mapp: print mapp[k],str(float(mapp[k])/100000 * 100)+\"%\"","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"random","slug":"random","permalink":"https://blog.nofile.cc/tags/random/"}],"keywords":[]},{"title":"Expression Add Operators","slug":"ag-282","date":"2016-08-20T11:06:00.000Z","updated":"2017-05-08T15:37:44.731Z","comments":true,"path":"posts/2016/08/20/ag-282.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-282.html","excerpt":"","text":"282. Expression Add OperatorsGiven a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Examples: &quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;] &quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;] &quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;] &quot;3456237490&quot;, 9191 -&gt; [] 分析题目要求找到所有的计算方案。是一个明显的dfs问题。关键是想清楚dfs的方式。dfs的参数大概是这几个。要记录答案retList ，输入参数num，当前的target，当前搜索到字符串内的位置pos，当前的搜索路径path，当前的数字值current，前面的数字值prev。还要注意防止00这样的数字出现，所以在搜索是要对00这样的case进行下清理。 代码class Solution(object): def addOperators(self, num, target): \"\"\" :type num: str :type target: int :rtype: List[str] \"\"\" ans = [] self.solve( num , target , ans , 0 ,\"\" ,0 ,0) return ans def solve(self , num , target , retList , pos , path , current , prev ): if len(num) == pos: if current == target: retList.append(path) return for i in range(pos , len(num)): if i != pos and num[pos] == '0': break; curstr = num[pos:i+1] currentval = int(curstr) if pos == 0: self.solve(num , target , retList , i+1 , path + curstr , current + currentval , currentval) else: self.solve(num , target , retList , i+1 , path + '+' + curstr , current + currentval , currentval) self.solve(num , target , retList , i+1 , path + '-' + curstr , current - currentval , -currentval) self.solve(num , target , retList , i+1 , path + '*' + curstr , current - prev + prev * currentval , prev * currentval)if __name__=='__main__': sn = Solution() num = \"105\" target = 5 print sn.addOperators(num , target)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"Longest Palindromic Substring","slug":"ag-05","date":"2016-08-20T11:06:00.000Z","updated":"2017-05-08T15:37:41.218Z","comments":true,"path":"posts/2016/08/20/ag-05.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-05.html","excerpt":"","text":"Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. 分析看到了将先将原字符串处理成带#的方式，觉着这样处理方便一些。这样处理之后，最长的回文子串一定是关于#中心对称的。所以在我们的算法中，只要对每一个字符j，判断它两边的最长对称串就可以了。整体的复杂度大概是o(n2)。注意对数组越界的处理。这个思路，用python实现了，无奈会超时，该用c实现就可以了。但是刚开始总有几个case和我本机测试不一样。以为oj出问题了，后面再本地多高了几组样例测试，发现本地其实也有问题。后面检查，是我的那个临时变量没有初始化。初始化了之后，ac，并且速度也还可以。作为参考，2份代码都贴了过来，我先写了python版本的，后面发现超时，就将python的翻译成了c版本的。除了char数组变量初始化的坑，其他的基本还好。以后写c代码，一定记得变量初始化。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char* longestPalindrome(char* s) &#123; char ts[2005]; memset(ts,0,sizeof(ts)); ts[0] = '#'; int cnt = 1; for(int i = 0; i &lt; strlen(s); i++)&#123; ts[cnt++] = s[i]; ts[cnt++] = '#'; &#125; int lents = strlen(ts); int max = 1; int pos = 0; for(int i = 0; i &lt;lents; i++)&#123; int currentMax = 1; for(int j = 0 ; j &lt; i ; j++)&#123; int l = i - j - 1; int r = i + j + 1; if(l &lt; 0 || r &gt;= lents)&#123; break; &#125; if( ts[l] == ts[r])&#123; currentMax+=2; &#125;else &#123; break; &#125; &#125; currentMax = (currentMax - 1) / 2; if (currentMax &gt;= max)&#123; max = currentMax; pos = i; &#125; &#125; s = (char *)malloc(2005*sizeof(char)); memset(s , 0 ,sizeof(s)); cnt = 0; for(int i = pos - max + 1; i&lt;pos + max ; i++)&#123; if(ts[i]!='#') s[cnt++] = ts[i]; &#125; s[cnt]='\\0'; return s;&#125;int main()&#123; char str[1000]; while(scanf(\"%s\",str)!=EOF)&#123; char * ans = longestPalindrome(str); printf(\"%s\\n\",ans); &#125; return 0; &#125; class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" ns = \"#\"+\"#\".join(list(s))+\"#\" max = 1 pos = 0 mlen = len(ns) for i in range(0,mlen): currentMax = 1; for j in range(0,i): l = i - j - 1 r = i + 1 + j if l &lt; 0 or r &gt;= mlen: break; if ns[l] == ns[r]: currentMax+=2 else: break; currentMax = (currentMax - 1) /2 if currentMax &gt;= max: max = currentMax pos = i return \"\".join(ns[pos - max: pos + max + 1].split(\"#\")) if __name__=='__main__': ns = Solution() st = \"jglknendplocymmvwtoxvebkekzfdhykknufqdkntnqvgfbahsljkobhbxkvyictzkqjqydczuxjkgecdyhixdttxfqmgksrkyvopwprsgoszftuhawflzjyuyrujrxluhzjvbflxgcovilthvuihzttzithnsqbdxtafxrfrblulsakrahulwthhbjcslceewxfxtavljpimaqqlcbrdgtgjryjytgxljxtravwdlnrrauxplempnbfeusgtqzjtzshwieutxdytlrrqvyemlyzolhbkzhyfyttevqnfvmpqjngcnazmaagwihxrhmcibyfkccyrqwnzlzqeuenhwlzhbxqxerfifzncimwqsfatudjihtumrtjtggzleovihifxufvwqeimbxvzlxwcsknksogsbwwdlwulnetdysvsfkonggeedtshxqkgbhoscjgpiel\" print ns.longestPalindrome(st)","categories":[],"tags":[{"name":"string","slug":"string","permalink":"https://blog.nofile.cc/tags/string/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"}],"keywords":[]},{"title":"String to Integer (atoi)","slug":"ag-08","date":"2016-08-19T03:27:00.000Z","updated":"2017-05-08T15:37:49.729Z","comments":true,"path":"posts/2016/08/19/ag-08.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/19/ag-08.html","excerpt":"","text":"String to Integer (atoi)implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析主要还是读题，其实题目还是挺不好读的，有好多细节，读不出来就会wa掉。因为计算过程中32int会溢出，所以结果返回用了long long。不知道用int是不是也可以实现。如果很在意时间的话，题目中应该可以看出，可能包含大量无效字符的case，所以直接忽略这类case，应该可以节省不少时间。 代码#include &lt;stdio.h&gt;int myAtoi(char* str) &#123;#define M_MAX_INT 2147483648#define N_MAX_INT -2147483648 if(str == NULL) return 0; int cnt = 0; int positive_flag = 1; long long ans = 0; while(*str != '\\0')&#123; if(*str == ' ')&#123; if(cnt) break; str++; continue; &#125;else if(*str &gt;= '0' &amp;&amp; *str &lt;='9')&#123; ans = ans * 10 + (*str - '0'); if(ans &gt;= M_MAX_INT ) &#123; if(positive_flag)&#123; ans = 2147483647; &#125;else &#123; ans = N_MAX_INT; &#125; return ans; &#125; cnt++; &#125; else if(*str == '-')&#123; if(cnt) break; positive_flag = 0; cnt++; &#125;else if(*str == '+')&#123; if(cnt) break; cnt++; &#125;else &#123; break; &#125; str++; &#125; if(positive_flag) return ans; else return -1*ans;&#125;int main()&#123; char str[100] =\"\"; while(gets(str))&#123; printf(\"input is: %s\\n\",str); int ans = myAtoi(str); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"atoi","slug":"atoi","permalink":"https://blog.nofile.cc/tags/atoi/"},{"name":"math","slug":"math","permalink":"https://blog.nofile.cc/tags/math/"}],"keywords":[]},{"title":"leetcode LRU Cache","slug":"ag-146","date":"2016-08-18T15:29:00.000Z","updated":"2017-05-08T15:37:48.541Z","comments":true,"path":"posts/2016/08/18/ag-146.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/18/ag-146.html","excerpt":"","text":"LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析读完题目，其实最核心的部分就是维护一个LRU的顺序，能够在需要淘汰数据的时候以o(1)的算法选出需要淘汰的节点。Python中有有序字典这种数据结构。这种字典可以将字典中的所有(k,v)按照插入顺序来保存。新插入的在后面。并且还提供了popitem方法。正好符合这个题目的要求。popitem(last=True|False),last = False 表示按照FIFO进行pop，True表示按照LIFO进行淘汰。注意边界。插入和访问都需要先将元素从这个OrderedDict中删除，以维护LRU所需要的顺序。 如果没有这种结构的话，可以自己实现一个双向链表来解决这个问题。这样链表结构的调整比较容易，如果是数组的话，将一个元素放在最前面，是要调整整个数组的顺序的，成本太高，这种情况，链表就很有优势,这就是用链表的最重要的原因吧。 代码import collectionsclass LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self.capacity = capacity self.ldict = collections.OrderedDict() def get(self, key): \"\"\" :rtype: int \"\"\" try: value = self.ldict[key] del self.ldict[key] self.ldict[key] = value return value except: return -1 def set(self, key, value): \"\"\" :type key: int :type value: int :rtype: nothing \"\"\" print self.capacity print self.ldict try: del self.ldict[key] self.ldict[key] = value except: if len(self.ldict) == self.capacity: self.ldict.popitem(last=False) self.ldict[key] = value def mprint(self): print self.ldictif __name__=='__main__': lru = LRUCache(3) lru.set(1,1) lru.set(2,2) lru.set(3,3) lru.set(4,4) lru.set(5,5) lru.set(3,3) lru.set(6,6) lru.mprint() pass","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"lru","slug":"lru","permalink":"https://blog.nofile.cc/tags/lru/"},{"name":"ordereddict","slug":"ordereddict","permalink":"https://blog.nofile.cc/tags/ordereddict/"}],"keywords":[]},{"title":"leetcode Mini Parser","slug":"ag-385","date":"2016-08-18T15:03:00.000Z","updated":"2017-05-08T15:37:47.352Z","comments":true,"path":"posts/2016/08/18/ag-385.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/18/ag-385.html","excerpt":"","text":"Mini ParserGiven a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,’,’ , ].Example 1: Given s = “324”, You should return a NestedInteger object which contains a single integer 324.Example 2: Given s = “[123,[456,[789]]]”, Return a NestedInteger object containing a nested list with 2 elements: An integer containing value 123. A nested list containing two elements: An integer containing value 456. A nested list with one element: An integer containing value 789. 分析应该是一个字符串处理的问题。对特殊字符进行处理，处理事件主要由[,]来触发。o(n)算法。需要想清楚对每一个字符的处理方式。NestedInteger的维护，会使用到栈这种结构，在Python里面，list可以当作栈来使用。这个题目的边界条件，主要是[]里面可能是空的。整个过程有一点小复杂，主要还是靠自己思考，脑筋动起来吧。示例代码中的NestedInteger的class的方法是我自己加的，为了测试代码，测试语法问题。 代码class NestedInteger(object): def __init__(self,elem=None): pass def add(self , a): passclass Solution(object): def deserialize(self, s): \"\"\" :type s: str :rtype: NestedInteger \"\"\" lst = [] last_ic_ix = 0 if s[0] != '[': return NestedInteger(int(s)) for i in range(0,len(s)): if s[i] == '[': ns = NestedInteger() lst.append(ns) last_ic_ix = i elif s[i] == ',' or s[i] == ']': ss = s[last_ic_ix+1:i] if ss != '': tmp = int(ss) lst[len(lst)-1].add(NestedInteger(tmp)) last_ic_ix = i if s[i] == ']': top = lst.pop() if len(lst) == 0: return top lst[len(lst)-1].add(top) return Falseif __name__=='__main__': ns = Solution() print ns.deserialize(\"[123,3,[32,2,[33,24],3]]\");","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"stack","slug":"stack","permalink":"https://blog.nofile.cc/tags/stack/"},{"name":"python","slug":"python","permalink":"https://blog.nofile.cc/tags/python/"}],"keywords":[]}]}