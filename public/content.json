{"meta":{"title":"faith","subtitle":"leetcode学习笔记","description":"技术笔记，leetcode学习","author":"faith","url":"https://blog.nofile.cc"},"pages":[{"title":"About","date":"2016-08-15T03:59:07.000Z","updated":"2016-08-23T12:47:04.000Z","comments":true,"path":"about/index.html","permalink":"https://blog.nofile.cc/about/index.html","excerpt":"","text":"经历2014年毕业,在美丽说,一直在HIGO这个部门，后面HIGO独立，随HIGO一起到新HIGO。 本科期间，喜欢打魔兽， 经常逃课去打游戏，学习成绩一般，能勉强过关的那种。 大二接触linux，之后就再也没有丢开过，花了很多时间去折腾。从桌面开始，从fedora, 到ubuntu，到arch， 再到ubuntu。在这方面花了不少时间。 觉着linux的命令行才是真正的命令行，linux桌面才是真正的桌面，虽然很不稳定，经常 崩溃又从头再来，并 且很容易出各种奇怪的问题，但当时觉着也没什么，遇到什么问题，就 去找那个问题，知道那个问题解决。比如， 有时候我折腾了一晚上，就是为了让我的 linux系统可以识别我的U盘。经常更新下显卡驱动，就搞得进不去桌面系 统，当时不太会，干脆 重装，于是又来一遍。总之，各种各样的问题，花了好多时间，但那时候的我，好像并不觉 得烦， 一遍一遍得重复，似乎还有不少乐趣。 一遍遍的重复，对linux也慢慢了解了，重装系统的次数也越来越少。意识到和系统折腾其实也意义不大。 于是将更多的精力放在了写cpp上。初次见面，就是从写cpp开始的。发现写一个cpp竟然不用建工程。写一个 文件就可以了。和windows上vc6.0臃肿工程相比，在linux上竟然如此简洁，给我的那种惊喜，在哪个瞬间就 将我的兴趣俘虏了。之后，写cpp基本就在linux上了。 大学期间的算法和数据结构，基本都是在linux写的。 大四的实习，宣布着我程序员职业生涯的开始。 刚开始的工作，就给我分到了后端组。发现学校里的学习还是帮了我不少。 短暂的实习结束，从天津来到北京，进 入HIGO。同样是做后端，除了没怎么用过PHP，但对服务器和mysql这些 东西我基本都是熟悉的，所以进入状态也很快， 大概过了一周，我就可以熟练的写业务代码了。 在框架中编写代码，有一个缺点就是大部分代码都是模仿，所以并不 难。也没有什么挑战。 后面，需要做运营后台。和接口不同的是，这里要求界面，需要用web前端相关的。被迫要写一 些前端页面相关 的东西，刚开始做的那段时间，有一些界面，确实是不小的挑战，然后就是各种补，各种查，各种加班， 磕磕绊 绊搞出来的东西，一来长得其丑无比，二来烂的就像一坨..，三来写法落后的一逼，但是那时候我们团队没有人 擅长啊，我做出来的东西，我也觉着不太行，就勉强可以用, 当时大家的心思都在集中在客户端，后台的东西， 差不多 能用就可以了,大家也表示可以理解。 后面，有反馈，说整个页面刷新极大的影响运营效率，我才学会了ajax局部更新数 据，将一些要紧的地方更新了下。 慢慢的，我也跟着了解着，学习着前端。 几乎同时，我还负责了我们推送系统的构建。当时，邻居团队的项目已经有了，直接送给了我们，因为是python做的。 我之前懂一点，于是这个项目就给我了。但其实我的当时的python水平就比helloworld水平高一点呀。但我还是很自信 的接过 来了，没关系，不会可以学吗。代码都有了，看不懂查查不就懂了。 就这样，我接手了我们的push系统。 这个项目，我一直维护到今年3月份。期间除了不少问题。主要我们的APP内有聊天系统。一方面是推送系统要和聊天系统 对接，他们之间有的较多的环节,这些环节的设计上有一些误差。另一方面，大概是因为我写代码的能力不够，当时还没 有能力构建一个健壮的应用，这应该也是主要原因吧。我的推送程序经常跑着跑着自己就挂了。不过迭代了几个版本之后， 也基本趋于稳定了。 其他的时间，几乎就一直是客户端发版，写一些临时的为大促准备的接口,和修bug。其实技术方面的挑战，真没什么。最大 的挑战我觉着就是事情太多，虽然都没什么技术含量，但是事情多呀，多到让你没有周末，周末在家里也不能安宁，一会又 问题，在群里@你，你就不能不看。那时候的周末，应该只比工作日好一点，好的地方就是可以在家办公。 就这样过了大概2年。7月中旬，决定辞职。2016年8月10号，离职。 感悟最近面试，有一个感觉就是，工作了2年，其实并不一直都是成长的。前面1年感觉还好，但是第二年就很马虎了。在面试的时候，发现好多知识都很零散，没有系统，没有一个纲领，所以后面一年中，自己出了问题，自己也不怎么感觉得到，日子就是在划水。 受此启发，前连天整理了下自己的知识体系(图一) 它并不表明我掌握了面列举的所有，但我学习的时间，基本上都是和他们有关，从另一方面来看，这也是以后发展的一个方向。不管做什么样的业务，在什么样的公司，希望自己不再迷芒,实在不知道该干什么时，可以从这个图上一点点来突破。"},{"title":"tags","date":"2016-08-17T06:15:40.000Z","updated":"2016-08-17T06:17:31.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.nofile.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C/C++ 学习笔记","slug":"note-c","date":"2016-10-09T07:23:05.000Z","updated":"2016-10-09T07:23:05.000Z","comments":true,"path":"posts/2016/10/09/note-c.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/note-c.html","excerpt":"","text":"C文件的编译过程编译一个c文件，产生一个可执行文件，这个过程分为四个步骤 .c 文件到 .i 文件， --&gt; .s 文件 --&gt; .o 文件 --&gt; 可执行文件分别是预处理， 编译， 汇编， 链接 预处理所做的事情。 gcc -o helloworld.i helloworld.c -E 将 include 变成真实的东西 宏替换。 宏函数的优点。比一些函数要方便， 条件编译，对于程序的移植和调试，非常有用。 typedef 和 宏不一样的地方。给自己自定义的数据类型起一个别名。自定义的数据类型使用起来非常不方便。别名之后可以比较方便。typedef 是有作用域的。函数中的typedef，只能在函数中起作用。 ifndef 用法for example your .h file is named head.h and content like this. #ifndef _HEAD_H_#define _HEAD_H_this is your class definition area.#endif in your project, there are source file import it.for example. #include &lt;iostream&gt;#include \"head.h\"#include \"head.h\" if you include “head.h” twice, you find you can compile your file as well.but if your head.h is writte without #ifndef, #define #endif, then you mustwill get an error to stop your working. also, here the use of, #ifdef #else #endif this condition definition can save your release code size :). what is different between static type and dynamic type.static type: know when program is in compile process.dynamic type: know only in the run process. For pointer type. 计算一个数的算术平方根老师教过我们”牛顿迭代法快速寻找平方根”，或者这种方法可以帮助我们，具体步骤如下x= x+a/x;算法的原理其实不复杂，就是牛顿迭代法，用x-f(x)/f’(x)来不断的逼近f(x)=a的根。 float InvSqrt(float x)&#123; float xhalf = 0.5f*x; int i = *(int*)&amp;x; // get bits for floating VALUE i = 0x5f375a86- (i&gt;&gt;1); // gives initial guess y0 x = *(float*)&amp;i; // convert bits BACK to float x = x*(1.5f-xhalf*x*x); // Newton step, repeating increases accuracy return x;&#125; C++ rand lib#include &lt;stdlib&gt;srand((usigned)time(NULL));","categories":[{"name":"c++","slug":"c","permalink":"https://blog.nofile.cc/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://blog.nofile.cc/tags/c-c/"}],"keywords":[{"name":"c++","slug":"c","permalink":"https://blog.nofile.cc/categories/c/"}]},{"title":"读书笔记","slug":"note-read","date":"2016-10-09T06:38:00.000Z","updated":"2016-10-09T07:23:22.000Z","comments":true,"path":"posts/2016/10/09/note-read.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/note-read.html","excerpt":"","text":"关于阅读如果我一直以没有时间为理由，不去读书，是不是会越来越蠢。 Kindle资源 这个是一个不错的kindle资源网站。目前还比较好用。 https://www.jiumodiary.com/ 我的百度云里面也有不少书，想要的朋友可以从这里拿。https://pan.baidu.com/s/1i4TEMsH 读过的书 基督山伯爵 埋下仇恨，绝境中看到希望，逃生，获得意外的财富，体面的复仇。复仇复了好久，阅尽人间繁华，而不沉溺，实在厉害。 鲁滨逊漂流记 这个是自己打猎，落入荒岛，也是尽力生存，最后找到机会出去了，也获得了一笔意想不到的财富，过上了幸福的生活。 肖申克的救赎 有点励志，要抓住任何可以抓住的机会，不管处境多么难，都要有梦想，做成想做的事，永远不要放弃。 神雕侠侣 最近读完的,电视剧看了好久了，读小说感觉还是很不错的。读小说我只认人物，对杨过有不少喜欢，但感觉他并不完美，有时候也有些讨厌，不过这也算是正常的吧，哪里有完美的人，孰能无过。最讨厌的角色，感觉就是郭芙了,还有姓武的那两个小傻子。 明朝那些事 现在想来，看得基本都完了，有一点点印象，想到这本书现在只有一个想法，历史一直在重演，只不过是换了一批人。 貌似只读了这么多，可以看出来，我读书不多。","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://blog.nofile.cc/tags/阅读/"},{"name":"感悟","slug":"感悟","permalink":"https://blog.nofile.cc/tags/感悟/"}],"keywords":[]},{"title":"Path Sum II","slug":"ag-113","date":"2016-10-09T04:02:00.000Z","updated":"2016-10-09T07:22:58.000Z","comments":true,"path":"posts/2016/10/09/ag-113.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-113.html","excerpt":"","text":"Path Sum II和112类似，不过这次是要求出所有的解决方案。 For example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 return [ [5,4,11,2], [5,8,4,5] ] 分析简单的DFS，本质上是遍历所有的节点，找到解决方案，然后存储。需要注意的是，python的listcopy的时候需要用到deepcopy才行。可以用内部函数来简化编码。 代码import copyclass Solution(object): def pathSum(self, root, mSum): \"\"\" :type root: TreeNode :type sum: int :rtype: List[List[int]] \"\"\" ltMap = [] def travelRoot(root , currentVal , ltTmp): if root == None: return if root.left == None and root.right == None and root.val + currentVal == mSum: ltTmp.append(root.val) ltMap.append(copy.deepcopy(ltTmp)) return travelRoot(root.left , currentVal + root.val , ltTmp + [root.val]) travelRoot(root.right, currentVal + root.val , ltTmp + [root.val]) travelRoot(root , 0 , []) return ltMapdef run(): from common import CommonUtil root = None root = CommonUtil.generateTree(root) CommonUtil.printTree(root , 0) ns = Solution() ret = ns.pathSum(root , 17) print ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://blog.nofile.cc/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"Path Sum","slug":"ag-112","date":"2016-10-09T02:49:00.000Z","updated":"2016-10-09T07:22:56.000Z","comments":true,"path":"posts/2016/10/09/ag-112.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-112.html","excerpt":"","text":"Path SumGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 分析应该就是一个简单的DFS.代码里面的common class 是为测试写的类,实现在这里。因为最终有没有只能等到叶子节点才能知道，所以说只要每个节点的2个叶子中有一个返回True，那么就存在这个方案。 代码# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: bool \"\"\" currentVal = 0 return self.travelRoot(root , currentVal , sum) def travelRoot(self , root , currentVal , tSum): if root == None: return False if root != None and root.left == None and root.right == None: if currentVal + root.val == tSum: return True l1 = self.travelRoot(root.left , currentVal + root.val , tSum) l2 = self.travelRoot(root.right, currentVal + root.val , tSum) return l1 or l2def run(): from common import CommonUtil root = None root = CommonUtil.generateTree(root) CommonUtil.printTree(root , 0) ns = Solution() ret = ns.hasPathSum(root , 17) print ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://blog.nofile.cc/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"Best Time to Buy and Sell Stock","slug":"ag-121","date":"2016-10-09T02:37:00.000Z","updated":"2016-10-09T07:22:59.000Z","comments":true,"path":"posts/2016/10/09/ag-121.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/10/09/ag-121.html","excerpt":"","text":"Best Time to Buy and Sell Stock题目要求是如何购买可以获益最大,比较简单，但还是比较有意思的。两个样例如下： Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0 In this case, no transaction is done, i.e. max profit = 0. 分析我们有两个变量，分别是购买价格和最大获益值。开始的时候先购买第一天的，然后后面每一天都这样判断，如果当天的价格小于上一次购买，那么把上一次购买换成今天的价格，如果不小于的话，那么看当天的获益是不是比前面一次的获益多，如果是的话，就更新一下最大获益值。 代码class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if len(prices) == 0: return 0 bought_price = prices[0] max_benefit = 0 for i in prices: cnp = i - bought_price if cnp &lt; 0: bought_price = i elif cnp &gt; max_benefit: max_benefit = cnp return max_benefit def run(): sol = Solution() tst = [7, 1, 5, 3, 6, 4] ans = sol.maxProfit(tst) print ans pass","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://blog.nofile.cc/tags/dynamic-programming/"}],"keywords":[]},{"title":"前端笔记","slug":"note-web","date":"2016-09-09T06:43:00.000Z","updated":"2016-10-09T07:23:30.000Z","comments":true,"path":"posts/2016/09/09/note-web.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-web.html","excerpt":"","text":"marginmargin: 的4个参数。up ,right, down , left;如果只有一个参数，那么表示4个都是n px。可以是1–4个参数。 some input typeradio, checkbox , button, 他们都有对应的时间，可以在里面添加对应的 函数。可以带参数的。checkbox 也可以写成数组。name=’chk[]’ $_REQUEST [‘chk’] 取值的方式是这样的。 fontawesome学习两个前端页面会使用到的js. https://www.woothemes.com/flexslider/ 这个是用来做轮播图的js。http://fontawesome.dashgame.com/这个是用来给页面中显示一些字体用的。还有一些常用的图标，用法也很简单， ####304 错误. 强制不从本地设备读取内容. &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"expires\" content=\"0\"&gt; Node基础http://npm.taobao.org/首先是npm， node package manager, 这个还相对好理解。可以用淘宝的镜像，速度会快一点。换一个淘宝镜像。例外是nvm，这个是node version manager。node 的版本太多了，所以也有了一个manager。nvm 可以选择安装 node 的版本，也很方便。nvm可以从这里下载。https://raw.githubusercontent.com/creationix/nvm/v0.4.0/install.sh 在一个node的项目里，可以通过cnpm install来安装项目依赖。这里推荐一个node的应用[hexo]https://hexo.io/.我的blog就是基于这个做的。 在页面中中使让一段文字在一个div中垂直居中？http://stackoverflow.com/questions/79461/vertical-alignment-of-elements-in-a-div","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://blog.nofile.cc/tags/html/"},{"name":"css","slug":"css","permalink":"https://blog.nofile.cc/tags/css/"}],"keywords":[]},{"title":"Ubuntu学习笔记","slug":"note-ubuntu","date":"2016-09-09T06:42:00.000Z","updated":"2016-10-09T07:23:27.000Z","comments":true,"path":"posts/2016/09/09/note-ubuntu.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-ubuntu.html","excerpt":"","text":"制作 ubuntu 镜像sudo dd if=/home/your.iso of=/dev/sdb 安装 fcitx 搜狗输入法。 确保你的语言包是全的。 安装这个语言包。http://pinyin.sogou.com/linux/ 按照这个做 http://jingyan.baidu.com/article/adc815134f4b92f722bf7350.html 安装firefox 插件json, vimperator, firebug. 安装 nginx ， php ， mysql ， php-redis 扩展。nginx http://nginx.org/en/download.htmlphp http://php.net/get/php-5.6.15.tar.gz/from/a/mirror php 编译参数. sudo apt-get install libcurl4-openssl-devsudo apt-get install libssl-devsudo apt-get install libxml2-dev./configure --prefix=/home/faith/blackh/server/php --with-config-file-path=/home/faith/blackh/server/php/etc --with-mysql=/usr/ --with-iconv-dir=/usr/ --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-fpm --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-zlib --enable-pdo --with-pdo-mysql --with-mysql=shared,mysqlnd 安装php-redis 扩展。http://pecl.php.net/package/redisphp nginx 配置,这些也很重要。 tmux vim slowstarttmux 中vim slow start 的原因,就是因为开了多个tmux,启动速度就变慢了.查看了slowlog,发现是因为xsmp消耗了大概1s的时间.只要保证一个tmux运行就可以了. grub customersudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get install grub-customizer 让你的ubuntu文件夹变成彩色的.可以添加下面的ppa,添加这个sudo add-apt-repository ppa:costales/folder-color然后安装下面这个 folder-color 就可以了.sudo apt-get install folder-color ubuntu安装更新版本的软件在linux中,我想升级gedit,比如说我的是 ubuntu14.04, 但是在 ubuntu15.10 里面,gedit 的版本是比我的新的.但是在14.04里面我确用不了最新的gedit .这个时候,我可以从官网下载最新的gedit ,安装,然而安装的时候会出现一些问题.这时候怎么办呢.可以这样. sudo apt-get build-deb geditsudo apt-get build-deb libreoffice5.0 然后执行安装命令就可以了.安装应该不会出错了.下面解释一下这个命令究竟是做什么的. ubuntu get source code如何获取ubuntu的源码你可以获取任何一个你所使用的源码包.这就是开源的系统.只要你的系统的源里有dep-src 这个选项,那么就可以随便获得系统源码.就像下面这样. deb-src http://archive.canonical.com/ubuntu trusty partnerdeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty universedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricteddeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universedeb-src http://extras.ubuntu.com/ubuntu trusty maindeb-src http://security.ubuntu.com/ubuntu trusty-security main restricteddeb-src http://security.ubuntu.com/ubuntu trusty-security multiversedeb-src http://security.ubuntu.com/ubuntu trusty-security universe使用下面的命令.sudo apt-cache showsrc gedit #showsrc 可以用来查询有没有你需要的源码包sudo apt-cache source gedit #source 命令用来获取你需要的源码包 ubuntu自己编译出deb当然在这些工作之前,我们需要确保安装一些基本的工具.dpkg-dev 先安装这个. 在编译源码包之前,需要安装具有依赖关系的软件包,可以使用这个命令,就是上面的那个.build-dep 命令. sudo apt-get build-dep xxx#通过上面两个命令,就可以得到自己的源码包了.然后利用cd yoursrcsudo dpkg-buildpackage 这样就可以得到你的dep文件了.可以使用下面的命令来安装deb文件.sudo dpkg -i *.deb 有了上面的知识,你就可以利用自己的系统,学习各种工具的源码了,包括vim , emacs.加油吧.^_^ 关于ubuntu 的dash 残留应用的问题在你的本地文件里面. .local/share/applications/ 里面把对应的删除,重新登陆就可以看到你讨厌的那个东西不见了.下面是我的 ubuntu dash 中的eclipse的快捷方式.可以很明显的看到是我的路径出了问题. 我需要修改一下路径就可以了. ubuntu 安装中文字体sudo apt-get install mysql-workbenchsudo apt-get install ttf-wqy-microhei sudo apt-get install ttf-wqy-zenhei nmap 具体的参数还需要进一步阅读手册。nmap -PS 192.168.0.102 #扫描一个主机所有开启的端口。nmap -sP 192.168.0.* #扫描一个网段下的所有活动的主机。 Ubuntu create launcherubuntu launcher. alacarteubuntu 创建快捷方式．用这个软件．在mate桌面上安装创建自己的启动方式．要给我的zendstudio 创建．sudo apt-get install gnome-panel linux rm hidden filesrm -rf 是不会删除隐藏文件的.rm -rf .这个命令会过滤调. .. ,这两个目录是无法删除的. Ubuntu 关闭 crash reportubuntu 关闭没用的 crash report。sudo vim /etc/default/apport Ubuntu N卡驱动对硬件的了解是我的最大的弱点。电脑的什么显卡驱动啊，什么网卡驱动，我都没有搞清楚。 I installed latest nvidia drivers by this method: 幸好是可以上网，如果不能上网，我真是有点没招了。glxinfo | headhttp://askubuntu.com/questions/319671/how-to-change-the-graphics-card-driver-via-terminalubuntu-drivers devicesto get a list of your devices and identify the one you want. My output looked like this:ubuntu-drivers devices== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==modalias : pci:v000010DEd00000391sv00001462sd00000630bc03sc00i00vendor : NVIDIA Corporationmodel : G73 [GeForce 7600 GT]driver : nvidia-304 - distro non-free recommendeddriver : nvidia-173 - distro non-freedriver : xserver-xorg-video-nouveau - distro free builtindriver : nvidia-304-updates - distro non-freeI wanted nvidia-304 so I typed:apt-get install nvidia-304 Then I rebooted and confirmed using the desktop appliaction Additional Drivers that I was indeed using the driver I had chosen. 我遇到的最本质的问题是，我不会在命令行下安装显卡驱动，切换显卡驱动。所以导致各种问题。上面的命令正好是教会这个。 ubuntu重启gui执行完上面的安装命令，然后 startx sudo service start lightdm 就可以启动了图形界面了，回到原来的样子。 aglike ack but faster. lspci glxinfo | head 如果显卡驱动有问题，这个命令会不正常。正常的话，会列出来一些相关的东西。 modinfo系统默认安装的驱动是这个。xserver-xorg-video-intelmodprobe -r nouveau 用这个命令来卸载这个模块，从内核中卸载这个模块。 ubuntu enable sudo for work# provided their password# (Note that later entries override this, so you might need to move# it further down)%sudo ALL=(ALL) ALL then add the sudo group just like this;groupadd sudosudo usermod -aG sudo work http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html ubuntu firefox flash遇到的问题是 firefox has prevented the outdated flashplugin from xxx website.我从官网下载 tar.gz 之后，安装还是没有解决问题。貌似要用 apt-cache 来搜索才行，现在貌似好了，问题就是这样解决的。sudo apt-get install flashplugin-downloader貌似真得好了。 Linux 更新时间Linux 更新时间.主要的就是这个命令.ntpdate cn.pool.ntp.org好像 windows 时间 和 Linux 时间一定会又一个出问题.现在有点没有办法.将时间写入到 cmos 主要是系统时间写入 硬件时间 和 硬件时间写入系统的区别.sudo hwclock –systohcsudo hwclock –hctosys 允许程序没有sudo权限执行sudo chmod +s /usr/sbin/hddtemp这样就可以让 hddtemp 在没有 sudo 权限的情况下运行了。 xargsok, today I learned about xargs command. this solve the problem like this.rm -rf lsnow you can do like this;ls | xargs rm -rf","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.nofile.cc/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.nofile.cc/tags/ubuntu/"}],"keywords":[]},{"title":"sphinx学习笔记","slug":"note-sphinx","date":"2016-09-09T06:42:00.000Z","updated":"2016-10-09T07:23:25.000Z","comments":true,"path":"posts/2016/09/09/note-sphinx.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-sphinx.html","excerpt":"","text":"sphinx实践用shpinx实现一个搜索相关的小项目需要安装sphinx，然后和mysql配合使用。 sphinx安装配置编译安装sphinx。 中文分词需要下载一个中文字典，应该有好多现成的。","categories":[],"tags":[{"name":"sphinx","slug":"sphinx","permalink":"https://blog.nofile.cc/tags/sphinx/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.nofile.cc/tags/搜索/"}],"keywords":[]},{"title":"mac常用软件","slug":"note-software","date":"2016-09-09T06:42:00.000Z","updated":"2016-10-09T07:23:24.000Z","comments":true,"path":"posts/2016/09/09/note-software.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-software.html","excerpt":"","text":"charles APP代理软件charles 破解。我的link。 http://pan.baidu.com/s/1i4UUbOh Dash非常便捷的API手册，方便查询。 PhpStormPHP 开发的好帮手，可以帮你避免一些低级错误。 WebStorm和Phpstorm是同一个公司开发的，使用上和PhpStorm 差不多,用于偏前端的开发工作场景。 ipythonPython 命令行工具，和Python不同的是，这个可以进行命令提示，方便初学者。 Postman管理接口，方便重用，经常和一堆接口打交道的话，这个会很方便。 以上貌似除了postman，其他的都是付费的。不过买起来确实很贵，但破解都 相对容易，需要的话，请自行百度，都很简单。","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"},{"name":"工程效率","slug":"工程效率","permalink":"https://blog.nofile.cc/tags/工程效率/"}],"keywords":[]},{"title":"shell 学习笔记","slug":"note-shell","date":"2016-09-09T06:42:00.000Z","updated":"2016-10-09T07:23:23.000Z","comments":true,"path":"posts/2016/09/09/note-shell.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-shell.html","excerpt":"","text":"awkthe follow command can be used to restart php-fpm in server.ps aux | grep ‘php-fpm’ | awk ‘{print $1}’ | xargs kill -USR2-F option 是用来改变默认的分隔符的。awk -F ‘:’ ‘{print $3}’awk 的 BEGIN 和 END 语句的功能。BEGIN 是最开始的部分执行的，然后AWK开始读取文件内容，进行处理。END 是最后面结束执行的. sed的简单例子sed &apos;s/xx/ds/&apos; note[ ! -x result ] &amp;&amp; mkdir resultfor i in `ls *.grb`do out=`echo $i | sed &apos;s/GLDAS_NOAH10_M.A//&apos; | sed &apos;s/\\..*[[:graph:]]//&apos;` wgrib $i &gt; result/$out&quot;.out&quot;donesed -i &quot;This command to use replace the input file&quot;just a simple example.sed -i &apos;s/--/-/&apos; d 表示是删除的意思。用新文件覆盖旧文件。sed ‘/vim/d’ ~/.bashrc &gt; ~/.bashrc刚才才发现原来 shell 的字符串判断相等是 = 左右两天加个空格就可以了。如果不加空格就是赋值。这种语法还是有点诡异的啊。并且现在很少写 if 这个东西了，自从我发现了 if 语句可以简写之后。字符串操作还是又必要掌握一下的。果然shell python 相比来说直截了当多了。正事因为 shell 在字符串处理上的缺陷，所以才有了sed这样的工具来补充吧。当然还有awk。 grepgrep -E 支持扩展的正则grep -o 只输出指定内容, only-match 的含义grep -F 相当于 fgrepgrep -v 不匹配指定正则的指令grep 输出匹配内容的上下两行内容,输出上下文,记得这个参数.grep -C 2 ‘linux’grep -i 进行大小写无关的搜索grep -P perl分格的正则 grep -i -Po &quot;HREF=\\&quot;.*?\\&quot;&quot; bookmarks_4_27_15.html find使用的例子下面这个script结合了find 的regex参数的用法。find regex 和 那么的区别还是挺大的。regex搜索的输出是全名的，name知识一个短的名字。 #!/bin/bash# 要搜索的路径。path=&quot;$HOME&quot;for i in `find $path -regex &quot;.*/[0-9]\\&#123;6\\&#125;/*&quot; -type d 2&gt;/dev/null`do echo $i for j in `ls $i` do echo $j m=`echo &quot;$j&quot; | cut -d. -f2` if [ $m != &apos;log&apos; ] then echo &quot;mv for $j&quot; mv $i&quot;/&quot;$j $i&quot;/&quot;$j&quot;.log&quot; fi donedone shell重定向来自这个链接 http://www.cnblogs.com/yangyongzhi/p/3364939.html ./Test.py 1&gt;normal 2&gt;error 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3./Test.py 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 1&gt;normal 2&gt;error 可以通过这两个命令看出差别,其实就是从右向左执行的. 具体的执行过程是这样的,一个完整的shell指令的执行是从右往左的.先执行 1&gt;&amp;3 , 然后执行 2&gt;&amp;1 , 3&gt;&amp;2 nohup的使用在mac中，在tmux中使用nohup会有问题，会抛出下面这样的错误。所以只能在开一个终端执行。nohup: can’t detach from console: Undefined error: 0nohup redis-server &amp; &gt;/dev/null git 跨源合并一个项目可以添加多个源,origin是默认的一个源.并且也可以跨源合并.这是比较高级的用法.如果要跨项目合并. git 跨项目合并. git remote add code “url”git push code master shell get your ipifconfig | grep -E -o &quot;inet ([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1ip a| grep -E -o &quot;inet addr:([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | grep -E -o &quot;([0-9]&#123;1,3&#125;.)&#123;3&#125;([0-9]&#123;1,3&#125;)&quot; | tail -n 1 linux 下 ifconfig | grep ‘inet ‘ | awk ‘{split($2, ip_cntr, “:”); print ip_cntr[2];}’ tmux.conf想在tmux.conf中添加一些shell脚本,可以获取到我自己的IP地址.这样我在连接代理的时候,就不用是自己查了.我把自己的tmux的status line 搞成了1s刷新一次.用了这个命令. git push –forcegit remote add. 将一个远端的项目添加到新的分支上,然后可以合并。git remote add name git@gitlabserver.meiliworks.com:higo/api.git删除这个分支。git remote rm old_pandoragit 将某个分支强制覆盖。比如我想用newpush 的代码完全覆盖 master 的代码。可以这样做。git push origin newpush:master -f git remote add origin url #这样可以讲自己的git目录添加到远端仓库.很方便.同一个项目可以添加多个远端仓库,可以一起使用. shell functions函数的返回值,函数的参数.http://www.jb51.net/article/33895.htm这里看到了一些参考,主要是这两个参数, $@ 和 $* 是一样的,可以将函数的参数当做一个字符串.如果你仍然利用$1,$#,$0这些而参数,那么你可能得不到你想要的结果.并且,我在shell下添加了一些常用的颜色的变量,只要. ~/.colorful 就可以使用这些变量了.可以进行一些彩色的输出,是得程序更加明确.其他的就是对shell更加熟悉了,大小的比较,相等的比较.还有if else elif 这样的语句,也好多了.我的那个启动脚本更加明确了. mount 命令 fstabLinux mount 可以讲一块磁盘挂在一个目录下.挂载之后,这个目录原来的内容就不存在了.如果umount 之后,这个目录下面的空间就出现了,这一定和底层的实现有关系.操作系统究竟是如何管理存储空间的,这些问题都是需要研究的.目前,所指导的可以解决这些基本问题了,我可以很好的扩展我的系统空间不足的问题,但是我觉着对于 如果要解决这个问题,还需要一些挂载的知识,我需要讲自己的磁盘挂在系统上,让系统启动的时候自动帮我挂上.而不是每次都让我自己去挂.mount 里面也有很多. fstab 的编写,其实还可以,就是将最前面的盘符换成具体的磁盘设备就可以了.可以像下面这样,把你的磁盘随便挂上去.这就是 home分区分开使用的好处,单独挂载一个磁盘之后,就具备比较好的扩展性了.只要内容没有损坏,就可以随便安装到任何一个新系统上去.大部分内容都是放在/home里面的,或者可以把自己常用的软件都安装在一个指定的目录下,这个目录可以 UUID=684e471c-215b-4520-b3d6-09c6e5316ee2 / ext4 errors=remount-ro 0 1# swap was on /dev/sda6 during installationUUID=08488fed-d6f4-4fa2-b935-dd599851d98d none swap sw 0 0/dev/sda5 /home ext4 defaults,noatime 0 0 刚才遇到的问题好奇怪 挂在分区之后,输入密码进不来系统,我发现是我的新的home目录没有权限,把owner 改成我自己,然后就可以利用图形界面进来了. 我进来之后,发现我的steam 用不了了,我拷贝了所有的文件,发现还是不行,再后来发现是我的home中的所有的二进制文件都没有办法执行,上网找,发现是我的挂在参数有问题,用了defaults,noatime 之后就好了.真是神奇. ssh-agentto start your ssh-agent, you need to eval this command.eval ssh-agent -s sudo ntpdate 202.120.2.101sudo ntpdate 210.72.145.44这是两个时间服务器，可以调整自己的时间。 shell 执行字符串命令。可以这样。eval $cmddate &apos;+%Y-%m-%d&apos;httpd -Sshell 脚本中的 空变量。可能是你的程序报错，所以写判断的时候需要考虑变量为空的情况。如果出现这样的情况，报的错误可能是这个。&quot;[: =: unary operator expected&quot;a=$(($i + 1))同时满足2各条件if test &quot;$dev&quot; = &quot;0&quot; -a &quot;$devok&quot; = &quot;0&quot; ; then echo &quot;your comment&quot; echo &quot;your comment&quot;exit 1fi 如何调试shell。bash -x your.sh 就可以看你的shell的执行过程了。或者在shell的开始部分增加一行，set -x。 crontabcrontab l 列出当前的任务。分 时 日 月 星期 执行命令,* 表示任意的变量;在linux 下，你当前用户的crontab文件存放在 /var/spool/cron/ 目录下，这个文件以你的用户身份命名。 00 23 * * * run-your script 每天23:00 执行你的脚本。其实我需要做的就是一行命令。10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart 这个任务表示每周6和周日的1:10重启服务器。注意逗号，表示多个的意思。再看下面一个。* */1 * * * /usr/local/etc/rc.d/lighttpd restart 注意这个符号/ 表示每个一个小时重启一下服务器。 netstat –tunlp |grep 90 Linux 守护进程set_time_limit(0); 设置程序的执行时间,如果是0说明永久执行下去.学习写守护进程,用PHP实现.或这其他的也行.每个进程都有一个父进程,子进程退出,父进程能得到子进程退出的状态.进程组, 每个进程都属于一个进程组,这个号码等于该进程组组长的pid. 设置VIM为shell的默认编辑器export VISUAL=vimexport EDITOR=”$VISUAL”git config –global core.editor “vim” git config core.fileMode false这样你的git就不会官 fileMode 的变化了，默认的模式是 true 的。 shell中的一些基本变量函数的返回值貌似可以用 $? 变量拿到。但是 return 是不支持返回非数字类型的。这是不是一个新的约束条件。对于数值运算，可以实用 expr 这个工具，其实这是另一个简单的工具，可以用 man 手册来查看帮助文档。shell 中有几个比较特殊的变量。$0 表示当前脚本的名字$1 $2 … $i 第 i 个参数$# 参数的个数。$?","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.nofile.cc/tags/shell/"},{"name":"awk","slug":"awk","permalink":"https://blog.nofile.cc/tags/awk/"},{"name":"sed","slug":"sed","permalink":"https://blog.nofile.cc/tags/sed/"},{"name":"grep","slug":"grep","permalink":"https://blog.nofile.cc/tags/grep/"}],"keywords":[]},{"title":"PHP 源码学习","slug":"note-php01","date":"2016-09-09T06:39:00.000Z","updated":"2016-10-09T07:23:18.000Z","comments":true,"path":"posts/2016/09/09/note-php01.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-php01.html","excerpt":"","text":"PHP弱类型的实现原理PHP是弱类型，动态的语言脚本。在申明一个变量的时候，并不需要指明它保存的数据类型。例如：动态变量，在运行期间是可以改变的，并且在使用前无需声明变量类型。 &lt;?php $var = 1; $var = \"variable\"; $var = 1.00; $var = array(); $var = new Object(); 问题一、Zend引擎是如何用C实现这种弱类型的呢？Zend/zend.htypedef struct _zval_struct zval; struct _zval_struct &#123; /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc; &#125;; typedef union _zvalue_value &#123; long lval; /* long value */ double dval; /* double value */ struct &#123; char *val; int len; &#125; str; HashTable *ht; /* hash table value */ zend_object_value obj; &#125; zvalue_value;Zend/zend_types.h：typedef unsigned char zend_bool; typedef unsigned char zend_uchar; typedef unsigned int zend_uint; typedef unsigned long zend_ulong; typedef unsigned short zend_ushort; 从上述代码中，可以看到_zvalue_value是真正保存数据的关键部分。通过共用体实现的弱类型变量声明 问题二、Zend引擎是如何判别、存储PHP中的多种数据类型的呢？ _zval_struct.type中存储着一个变量的真正类型，根据type来选择如何获取zvalue_value的值。 #define IS_NULL 0 #define IS_LONG 1 #define IS_DOUBLE 2 #define IS_BOOL 3 #define IS_ARRAY 4 #define IS_OBJECT 5 #define IS_STRING 6 #define IS_RESOURCE 7 #define IS_CONSTANT 8 #define IS_CONSTANT_ARRAY 9 来看一个简单的例子： &lt;?php $a = 1; //此时zval.type = IS_LONG,那么zval.value就去取lval. $a = array(); //此时zval.type = IS_ARRAY,那么zval.value就去取ht. 这其中最复杂的，并且在开发第三方扩展中经常需要用到的是”资源类型”.在PHP中，任何不属于PHP的内建的变量类型的变量，都会被看作资源来进行保存。比如：数据库句柄、打开的文件句柄、打开的socket句柄。资源类型，会用lval，此时它是一个整型指示器， 然后PHP会再根据这个指示器在PHP内建的一个资源列表中查询相对应的资源。正是因为ZE这样的处理方式，使PHP就实现了弱类型，而对于ZE的来说，它所面对的永远都是同一种类型zval。 原文链接 PHP中的排序函数有好多 asortusortksortrsortarsortkrsortuasortuksort","categories":[],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://blog.nofile.cc/tags/php源码/"}],"keywords":[]},{"title":"javascript 学习笔记","slug":"note-js","date":"2016-09-09T06:39:00.000Z","updated":"2016-10-09T07:23:08.000Z","comments":true,"path":"posts/2016/09/09/note-js.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/09/09/note-js.html","excerpt":"","text":"jquery常识如果$() 的括号里面是一个dom元素的话，这个东西就是一个jquery对象。jquery 的方法，on ，可以绑定事件，each可以循环遍历数组。同时js自己的array也是一个对象，有foreach方法。要注意和jquery的each 方法区分。js 几个常用的事件keyup onchange click js 的闭包函数，这几天php中也用了不少，一个是array_walk, usort()有些场景中用这些函数是很方便的，这些函数都有自己适合的场景，要在合适场景使用,才能体现出这些函数的作用。 js 正则.正则表达式各种语言基本都是类似的，选择任一种实现都可以。^匹配开头$匹配结尾除了一些最基本的之外，可以简单思考下下面这些问题 贪婪匹配跨行匹配. 尽可能多的匹配.? 匹配到一个就可以了 js localstoragejs localStorage.localStorage.getItem();localStorage.setItem(); underscoreUnderscore提供了100多个函数,包括常用的: map, filter, invoke — 当然还有更多专业的辅助函数,如:函数绑定, JavaScript模板功能,创建快速索引, 强类型相等测试, 等等. 详细的文档可以参见这里。http://www.css88.com/doc/underscore/ ####jquery on 的代理实现 记得有这样一个场景。一个页面里面会使用到弹层，弹层上面有一些按钮，需要给这些按钮绑定事件。可以使用on方法绑定。但是在js代码执行的时候，这个坦层并没有出现，页面中并没有这个dom对象。这个时候，需要用到on的另一种使用方法。在他的父元素上绑定。parent.on(‘click’,’selector’,function(){})是一种类似这样的用法，当时这个解决了个很重要的问题。jquery 中给一个元素中追加一些属性可以用append方法来实现。","categories":[],"tags":[{"name":"programming","slug":"programming","permalink":"https://blog.nofile.cc/tags/programming/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.nofile.cc/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"}],"keywords":[]},{"title":"Linux VPN 配置","slug":"note-vpn","date":"2016-08-29T06:43:00.000Z","updated":"2016-10-09T07:23:29.000Z","comments":true,"path":"posts/2016/08/29/note-vpn.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/29/note-vpn.html","excerpt":"","text":"ubuntu14.04 安装vpn这个是最正确的教程，没有之一。http://mad-scientist.us/juniper.html下面是一个简单的总结 sudo apt-get install libstdc++6:i386 lib32z1 lib32ncurses5 libxext6:i386 libxrender1:i386 libxtst6:i386 libxi6:i386sudo apt-get install openjdk-7-jre icedtea-7-plugin openjdk-7-jre:i386sudo apt-get install icedtea-pluginsudo apt-get install libc6-i386 lib32nss-mdnssudo apt-get install libgtk2-perl libwww-perlwget -q -O /tmp/msjnc https://raw.github.com/madscientist/msjnc/master/msjncchmod 755 /tmp/msjncsudo cp /tmp/msjnc /usr/bin http://www.scc.kit.edu/scc/net/juniper-vpn/linux/ 还可以参考这个帖子。需要得到realm这个东西，这个东西，去你公司的vpn网站爬一下就可以了。搜索一下realm这个字，就可以看到这个内容的值。最终推荐使用哪个客户端,比mac的客户端还好用。不过如果没有特别的爱好，还是用mac吧,折腾起来，还是有点麻烦的。","categories":[],"tags":[{"name":"vpn msjnc","slug":"vpn-msjnc","permalink":"https://blog.nofile.cc/tags/vpn-msjnc/"}],"keywords":[]},{"title":"vim 学习笔记","slug":"note-vim","date":"2016-08-28T06:43:00.000Z","updated":"2016-10-09T07:23:28.000Z","comments":true,"path":"posts/2016/08/28/note-vim.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/28/note-vim.html","excerpt":"","text":"vim的几个常用的插件。 插件 说明 ctags tags 的标签 vim-ariline 彩色 的状态栏 nerdtree 一个文件管理器 gittur git集成插件,可以显示修改了的内容 bundle 插件管理 vim-markdown 支持markdown的语法 VIMSCRIPT下面是一些简单的vimscript内容。 vim 中定义变量要用let a=123 空格并不能影响效果，这一点和shell并不一样.echo a这样就可以看到效果。在 vimrc 中可以写简单函数，来做一些想做的事情，比如根据文件后缀，自动执行脚本程序。:echo % 这个是获得当前文件的全名，包括后缀的。:echo %&lt; 和下面的一行作用一样。:echo %:r 这个是获取当前文件的文件名，除去扩展后缀 插入模式下的 vim ， ctrl + j 可以将文本内容下移一行。ctrl + m 我也不知道具体是什么，我只是通过实验尝试出来的。 VIM 启动速度慢 slowstartvim –startuptime vim.log -c qsudo vim 启动速度超级慢。vim 启动速度变慢.在终端中可以这样启动 vim -X 这样是不需要和X挂上勾的,所以会变慢.修改了一下之后瞬间感觉电脑变快了.vimariline这个插件会明显增加启动时间，加之没什么用，后面就从我的vim插件里面去掉了。 sudo vim 启动速度超级慢调查之后，发现是我把系统的hosts文件删除了，touch了一个空文件。后面，总是提示unresolve host 的提示。在增加了我的hostname在host中之后，sudo vim 速度就快了。开来和这个也有关系。 vim 记录上次编辑位置。au BufReadPost * if line(&quot;&apos;\\&quot;&quot;) &gt; 0|if line(&quot;&apos;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &apos;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif vim 删除重复行sortg/^\\(.\\+\\)$\\n\\1/d vim 插入当前时间插入时间，这个应该说是很方便的，但是我并不懂这个命令是怎么实现的。在vimrc中加入这个map，在normal模式下，输入,dt就可以在当前位置插入时间了。 map ,dt a&lt;C-R&gt;=strftime(&apos;%Y-%m-%d %H:%M&apos;)&lt;CR&gt; vim find天刚学到的是 find 命令，这个是用来打开文件用的，可以智能补全。set path=/home/yourpath vim 导入其他文件内容将当前文件的部分内容导入到其他文件1,20 w&gt;&gt; /path/otherfile.txt1,20 w /path/otherfile.txt具体命令就是这样。 同样的，也可以将其他文件的内容读入到当前文件来。命令是这个r: /path/file.txt 同时，这个命令也可以将外部程序的输出读入到当前文件中。r !date这样也是可以插入时间的。将这个命令用map命令映射一下，就可以得到和那个实现的同样的功能了。 VIM和系统共享剪切板首先需要补充的一点是，+寄存器是只有vim-gtk 或者 vim-gnome 才会有的，不要只安装了vim，这是不够的啦，在安装的时候需要注意一下，不然是无法使用系统剪切板的啦。复制单个字符， nyl n 是数字，l和vim的方向键一样，表示向后，就是向后复制n个字符。同理，nyh 表示向前复制n个字符。这样就可以很自由的复制了。复制单词 ynw 其中n是数字，表示要复制的单词的个数。按行为单位复制：nyy 表示复制n 行，和上面的命令差不多。应该是向下取的。p 表示粘贴，注意小写，这个是代表粘贴在下面。P 也表示粘贴，这次是大写啊，这个是代表粘贴在前面。估计对于字符复制粘贴的内容也是同样的规则啊。“+y 表示复制到系统剪切板去。这个应该忘不了吧。 vim 有很多的粘贴板，这些东西的用处你自己应该可以理解，一般情况下，都是只用一个粘贴板的，但是粘贴板多一点也是没有坏处的啊。vim中的复制是用y来完成的，在这之前，你当然可以决定你的内容是存放在那个粘贴办中，你可以用reg来查看这些粘贴板中都存了什么内容，同时p是用来复制的，你也可以在复制之前决定你从哪个粘贴板中复制内容，例如”4p表示是从4好粘贴板中拿东西。如果4好粘贴板中有你存下的内容的话，那么他就可以复制出来了，结合上面的命令，你当然可以做成你想做的。复制到第n 个粘贴板的命令: 先选择要复制的内容，然后”ny 就可以将这些内容放到粘贴板了。然后在你想复制的地方”+p 就可以了。","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://blog.nofile.cc/tags/vim/"}],"keywords":[]},{"title":"nginx 学习笔记","slug":"note-ng","date":"2016-08-26T06:41:00.000Z","updated":"2016-10-09T07:23:15.000Z","comments":true,"path":"posts/2016/08/26/note-ng.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-ng.html","excerpt":"","text":"nginx编译参数./configure \\ --prefix=/home/service/nginx \\ --with-http_ssl_module \\ --with-http_spdy_module \\ --with-http_realip_module \\ --with-http_addition_module \\ --with-http_xslt_module \\ --with-http_image_filter_module \\ --with-http_sub_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_mp4_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_auth_request_module \\ --with-http_random_index_module \\ --with-http_secure_link_module \\ --with-http_degradation_module \\ --with-http_stub_status_module \\ --with-pcre=/root/src/pcre-8.37 \\ --with-zlib=/root/src/zlib-1.2.8 \\ --with-openssl=/root/src/openssl-OpenSSL_1_0_2d \\ --add-module=/root/src/naxsi-0.54/naxsi_src \\ --add-module=/root/src/headers-more-nginx-module-0.27 \\ --add-module=/root/src/echo-nginx-module-0.58 \\ --add-module=/root/src/lua-nginx-module-0.9.18rc1 \\ --add-module=/root/src/redis2-nginx-module-0.12 nginx 中加环境变量.fastcgi_params define_params hhh nginx 配置规则 location 写法。 log_format nginx 的log_format , log 需要几下post参数。记得上次查问题，我只能定位到url，并不能定位 到参数，这导致有些问题没有办法追查。 nginx 和php-fpmnginx 启动和重启检测配置文件的正确性，不要加载一个又明显错误的配置文件nginx -t -c /usr/nginx/conf/nginx.conf#启动 停止 或者重启 nginx 。nginx -s reload nginx #重新加载配置文件pkill nginx #停止nginx","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[]},{"title":"PHP 学习笔记","slug":"note-php","date":"2016-08-26T06:41:00.000Z","updated":"2016-10-09T07:23:17.000Z","comments":true,"path":"posts/2016/08/26/note-php.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-php.html","excerpt":"","text":"PHP 回掉函数的使用。这是最基本的回掉方法。call_user_func_array(‘your function’,array());array() is your params. 刚才在文档里发现了好多东西，原来还是要自己编译才是最好的。才能够了解更多的特性。./configure –help其实已经包含了很多信息，只是你还不了解。要编译安装，这个是很重要的一步。 编译php常见的20个错误。http://crybit.com/20-common-php-compilation-errors-and-fix-unix/ PHP 扩展安装 PECLPECL is a repository for PHP Extensions, providing a directory of all known extensionsand hosting facilities for downloading and development of PHP extensions.PECL is very important. PHP 断言的使用。需要进行一些基本都的设置才可以。 assert_options(ASSERT_ACTIVE, 1);assert_options(ASSERT_BAIL, 1);$a = 'i1.23';assert(is_numeric($a));echo $a; PHP 正则表达式.preg_match 有几个关键词需要注意,一个是界定符 # / 这个可以自己设置的.preg_match 如果判断整个字符串的话,就要断言. 用 ^$.可以带 result 参数，将匹配的内容都放在这个result数组中。这个数组的参数应该是应用类型的。说到引用类型，我对这个还不是太清楚，没怎么使用过，应该熟悉一下。类似的函数还有 preg_match_all() , 返回值表示是否匹配.$name = \"hello\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'sas\";var_dump($name);$new_name = preg_replace(\"/\\\\\\*/\",\"\",$name);var_dump($name);var_dump($new_name); PHP urlencode, urldecode, rawurlencode, rawurldecode他们之间的差别还是比较小的,差别就是对+号的处理,我建议使用 rawurldecode, 而不是urldecode. 但这个改动不可以贸然,可能一起bug.在最初的时候设计的时候,就要考虑这一点. curl 参数curl 带json参数,需要加上-d 参数.没有这个参数是无法访问的.curl -d {goods_id:123123} “http://sss.ss.xx“ PHP array系列函数下面这个函数里面包含两种用法，一种是array_walk(), 还有一种是 变量的引用。这个和c语言是很相似的。$test = [1,2,3,5];array_walk($test , function(&amp;$i) &#123; $i++; &#125;);var_dump($test); PHP魔术方法__construct() 构造方法,生命类对象的时候就会调用.__desctruct() 析构方法,在类对象的生命周期结束之后. 这个和垃圾回收有什么关系吗.__call() must be public method.__callStatic() for static class method.__autoload().get_called_class() 一般是在基类中用到.基础类库中用这个方法.get_class(). 得到当前类的名称.static::class 和上面的得到同样的结果.PHP_EOL. 提高代码的可移植性. 换行符. mac windows, linux 下是不一样的.user_call_func() 这个方法是写自定义函数,利用这个方法,调用的函数会变成一个变量,所以非常灵活.user_call_func_array() 和上面的额方法类似,区别在于这里的方法的参数是数组.这些东西被统称为魔术常亮.__METHOD__ return the name of the function alongwith the class name.__FUNCTION__ just return the name of the function.__CLASS____FILE__ return filename of current file.__LINE__ return current line number.__DIR__ equal dirname(__FILE__). PHP SPL 方法 STANDARD PHP LIBRARYPHP 中spl 开头的一些方法是做什么的,比如spl_autoload_register.类似的方法还有不少,都是用来做什么的额.刚才调查了一下,确实有好多东西,这些都是PHP的高级语法,应该认真研究下,用好了,可以写出高效的代码. 对这门语言,我的了解还是不够,还需要认真研究.PHP SPL ==&gt; standard PHP library. PHP XHPROFXHProf是一个分层PHP性能分析工具。它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。一个函数的开销，可细分成调用者和被调用者的开销，XHProf数据收集阶段，它记录调用次数的追踪和包容性的指标弧在动态callgraph的一个程序。它独有的数据计算的报告/后处理阶段。在数据收集时，XHProfd通过检测循环来处理递归的函数调用，并通过给递归调用中每个深度的调用一个有用的命名来避开死循环。XHProf分析报告有助于理解被执行的代码的结构，它有一个简单的HTML的用户界面（ PHP写成的）。基于浏览器的性能分析用户界面能更容易查看，或是与同行们分享成果。也能绘制调用关系图。 PHP composerhttp://pkg.phpcomposer.com/ PHP 图像操作session_start();header(\"Content-type:image/png\"); $img_width=100;$img_height=20;srand(microtime()*100000);for($i=0;$i&lt;4;$i++)&#123; $new_number.=dechex(rand(0,15));&#125;$_SESSION[check_auth]=$new_number;$new_number=imageCreate($img_width,$img_height);//创建图象ImageColorAllocate($new_number,255,255,255); //设置背景色为白色for($i=0;$i&lt;strlen($_SESSION[check_auth]);$i++)&#123; $font=mt_rand(3,5); $x=mt_rand(1,8) + $img_width*$i/4; $y=mt_rand(1,$img_height/4); $color=imageColorAllocate($new_number,mt_rand(0,100),mt_rand(0,150),mt_rand(0,200));//设置字符颜色 imageString($new_number,$font,$x,$y,$_SESSION[check_auth][$i],$color);//输出字符&#125;ImagePng($new_number);ImageDestroy($new_number); PHP echo 和 print的区别。主要掌握echo的下面这两个特性。print更多的是一个函数。 echo \"hello\", \"world\";echo &lt;&lt;&lt;EOTtestEOT; PHP session 和 cookiePHP配置中介绍了session和cookie相关的配置。注意PHPSESSID这个东西,这个是通过session.name = PHPSESSID 来设置的。但是如果同一个server上部署了2个应用，那么两个应用的session.name都是相同的。不知道会不会有影响。完了我会测试一下。这个貌似不会相互影响。cookie会存放在不同的域名下面的。 PHP 配置那天发现我本地环境速度很慢的原因是 php-fpm.conf 中的maxchildren 数量太少了。我改成static 的，然后把最大数量变成128； 一下子就不用排队了。当时的现象是这样的。我看network，显示网络请求在排队，但是我完了单独访问每一个排队排了很久的接口，速度都很快，所以很疑惑。 PHP memcache 扩展和 memcached扩展memcache扩展比memcached扩展要早，但是功能上不如后者，memcache基本上只支持set和get。memcached可以支持更多方法。一般建议安装memcahced扩展。安装memcached扩展时需要安装libmemcached，memcache扩展则不需要。 PHP $_SERVER 变量PHP在命令行模式下的$_SERVER变量中的变量可以在shell中export来设置,shell中的变量会出现在SERVER变量中。在web环境中,要通过在服务器中设置才可以。nginx在fastcgi_params中设置。 session的相关配置。 session.save_handler = filessession.save_path = /tmpsession.use_cookies = 1session.use_only_cookies = 1session.name = PHPSESSIDsession.auto_start = 0session.cookie_lifetime = 0session.cookie_path = /session.cookie_domain =session.cookie_httponly =session.serialize_handler = phpsession.gc_probability = 1session.gc_divisor = 1000session.gc_maxlifetime = 1440session.bug_compat_42 = Offsession.bug_compat_warn = Offsession.referer_check =session.entropy_length = 0session.cache_limiter = nocachesession.cache_expire = 180#通过url传值，而不是cookiesession.use_trans_sid = 0session.hash_function = 0session.hash_bits_per_character = 5 PHP 开启slowlogPHP 异常","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/tags/web/"},{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"}],"keywords":[]},{"title":"Python 学习笔记","slug":"note-python","date":"2016-08-26T06:39:00.000Z","updated":"2016-10-09T07:23:20.000Z","comments":true,"path":"posts/2016/08/26/note-python.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/26/note-python.html","excerpt":"","text":"Python 内置函数__call__ __getattr__这两个内置函数是非常有用的,首先这两个函数是可以给类定义的.只有在class中才能实现这两个函数.__call__ 这个方法,可以让对象的实例作为一个无名函数被使用.实际上是给class重定义了()运算符. 每次通过实例访问属性,都要经过 __getattributge__() 如果属性没有定义,还需要访问 __get_attr__() __getitem__, __setitem__, __delitem__ 这几个方法比较容易理解,就是对一个类的实例,可以按照下标的方式进行访问. 无需过多解释. 参考资料 http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html ####创建一个类的静态方法, def A(object):@staticmethoddef hello(): return \"hello world\"def world(self): return \"class instance method\" ####静态方法 class A(object):@classmethoddef foo(cls): print 'class name is',cls.__name__def python REGULAR EXPRESSIOn正则中的正向引用的问题，其实还是有一定的问题的。我发现下面的引用并不能成功,不知道是为什么。所以只能放弃\\1的写法，重复写前面的那个。期望可以匹配出字符串中的日期。这个正向引用的问题，希望以后可以有机会解决。 regex= r\"[\\d]&#123;4&#125;(-)[\\d]&#123;1,2&#125;\\1[\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str)str = ['nasdfasfd2015-12-31' , 'asdlasdff2015-12-11']regex= r\"[\\d]&#123;4&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;[-|\\/|\\.][\\d]&#123;1,2&#125;\"ans = re.findall(regex , origin_str) file 你不知到的。 如果脚本是以相对路径被执行的，返回的是“” ， 并不会返回脚本当前目录。只有脚本是以绝对路径执行的时候，才会有对应的目录，这个问题需要注意。 shutil 可以操作文件目录，包括复制，移动，删除。比较常用。os.getcwd() 可以替代 os.path.dirname(file) , 这种方式有时候不如前者可靠。 python 变量不定义之前就使用是会报错的。 我发现上面的说法并不一定正确,getcwd 这个东西要小心使用,应该认真阅读一下这个方法的文档.它可能并不适用你的场景.在本质上,我需要的事这个东西. Python 获取当前脚本文件路径目录# -*- coding: cp936 -*-import sys,os#获取脚本文件的当前路径def cur_file_dir():#获取脚本路径 path = sys.path[0] #判断为脚本文件还是py2exe编译后的文件，如果是脚本文件，则返回的是脚本的目录，如果是py2exe编译后的文件，则返回的是编译后的文件路径 if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path) #打印结果print cur_file_dir() python excel 操作.完成了一个python 导入到处数据的功能.用到了这两个module xlwt, xlrd . 这个仅支持 xls 类型的excel. xlsx部支持.首先是安装 pip . sudo apt-get install python-devsudo apt-get install libmysqlclient-devsudo apt-get install python-pippip install mysql-pythonpip install xlwt pip install xlrd 数据库操作记得 commit .插入数据和写入数据的时候注意 转义.python MySQLdb 也可以绑定变量,这样可以不用关心特殊字符. 类似PHP. 全局变量的引用,应该使用global字段.python 从数据库中取出中文内容乱码.unicode 需要decode成utf8 的才可以,还需要其他的设置,完了需要一一验证. 下面是示例代码: 今天想到了python的爬虫框架。刚才查了一下，发现了scrappy这个东西。后面要找时间了解一下。http://www.jianshu.com/p/078ad2067419 python2.7的字符编码问题unicodedecodeerror: 'ascii' codec can't decode byte 0xef in position 0: ordinal not in range(128)import syssys.reload()sys.setdefaultencoding(\"utf-8\")","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://blog.nofile.cc/tags/python/"}],"keywords":[]},{"title":"PHP 与 FPM 的区别","slug":"note-phpfpm","date":"2016-08-25T15:47:00.000Z","updated":"2016-10-09T07:23:19.000Z","comments":true,"path":"posts/2016/08/25/note-phpfpm.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/25/note-phpfpm.html","excerpt":"","text":"PHP与FPM的区别nginx , fastcgi , php-fpm , php-cgi , cgi , php.ini , master process , work process , php kernel.这个问答写得很好,推荐参考。 首先nginx处理不了php这类的脚本程序，只能扔给php去做。最早的时候，php并没有php-fpm这个东西，后面php把fpm收进了内核，编译的时候，只需要enablefpm就可以了。php-fpm是一个实现了fastcgi的程序，后来被php收了。cgi 是一个协议，php-fpm 实现了这个协议。就可以和nginx通信了。cgi 的全写，common gateway interface 。为了保证web server 传递过来的参数都是标准格式的，方便cgi程序的编写，本质上是一个标准。 web server（比如说nginx）只是内容的分发者。比如，如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。 当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。 php-cgi 是php的解释器 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。 fastcgi是cgi的改进版，cgi每次都需要解析php.ini，这样做效率很低，后面就有了fastcgi，它有一个master进程，只有master进程中会load php.ini，然后后面有请求都只会fork一个child process去处理。可以实现平滑重启。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.nofile.cc/tags/php/"},{"name":"php-fpm","slug":"php-fpm","permalink":"https://blog.nofile.cc/tags/php-fpm/"},{"name":"fastcgi","slug":"fastcgi","permalink":"https://blog.nofile.cc/tags/fastcgi/"}],"keywords":[]},{"title":"leetcode 刷题笔记","slug":"note-leetcode","date":"2016-08-25T06:40:00.000Z","updated":"2016-10-09T07:23:10.000Z","comments":true,"path":"posts/2016/08/25/note-leetcode.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/25/note-leetcode.html","excerpt":"","text":"LEETCODE 学习笔记https://leetcode.com/ 可以按照分类做题。可以先做自己感兴趣的，easy 的 货这medium 的。hard的等最后了再做。不管怎么样的题目，对于一个搞代码的来说，做一下都是很有好处的，我觉着算法联系就好比是武侠世界中的内功，多多益善，勤于练习总是会有好处的。目前做了40个题目，做得比较少，做的题目中等的偏多一点，后面会继续做，作为业余爱好吧。不然业余时间还真没什么事做。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"}],"keywords":[]},{"title":"mysql笔记","slug":"note-mysql","date":"2016-08-24T06:40:00.000Z","updated":"2016-10-09T07:23:13.000Z","comments":true,"path":"posts/2016/08/24/note-mysql.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/24/note-mysql.html","excerpt":"","text":"mysql 性能测试工具.Mysqlslap 自带的性能测试工具. Mysql 基本知识一些mysql基本的操作show global variables like '%%datadir%' //看MySql数据库物理文件存放位置show variables like 'innodb_data%';set autocommit = 0lock table file_text writeunlock tablescreate table newtable select * from oldtable;INSERT INTO newTable SELECT * FROM oldTable;INSERT INTO newTable (col1,col2,…….) SELECT col1,col2,…… FROM old_tableinsert into myblog (id,title,ctime) values(123,'hello',now()) on duplicate key update title=values(title),ctime=values(ctime);//将 blog_bak 表中的所有数据导入到myblog 中，表 blog 和 blog_bak 应该有同样的表结构insert into myblog( blog,ctime) select * from blog_bak;if(tb2.shop_click is null, 0,tb2.shop_click) // mysql ifupdate table_a a , table_b b set a.shop_status = b.group_status where a.shop_id = b.shop_id; //这样可以将 table_b 的 状态同步到 table_a, 本质上和 多表查询是类似的。select * from xxx where id in (3,1,5) order by find_in_set(id,'3,1,5') order by substring_index和order by find_in_set都可以//select 按指定顺序排 Mysql 锁MysIsma, Memory 支持表锁。Innodb 支持表锁和行锁,默认是行锁。 BerkelyDB 支持页锁,页锁的粒度和成本在表锁和行锁之间,不知道是什么鬼。 乐观锁乐观锁可以通过增加一个version来实现。在提交的时候，带着version作为条件去更新，如果发现version不一致了，那么就不更新，如果和当时读取到的version一直才更新数据。 悲观锁的介绍，用到了select for update。要实现悲观锁，必须将数据库的autocommit属性置成0select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。select for update，现在使用select for update来查询数据，以达到排他读的目的。但是发现，在有正常结果数据时造成的锁表对系统性能有明显地影响。select for update的条件不是主键所以id，所以造成锁表。尽可能让所有数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定。 读锁和写锁 共享锁(S锁)又称读锁,若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S 锁.这保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改. 排他锁(X锁)又称写锁.若事务T对数据对象A加上X锁,事务T可以读A也可以修改A,其他事务不能再对A加任何锁,直到T释放A上的锁.这保证了其他事务在T释放A上的锁之前不能再读取和修改A. 并发事务处理带来的问题相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况。 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 Mysql 索引Mysql 索引 每次查询只能使用一个索引，所以如果在字段比较多的查询中，就算每个字段都创建了索引，也只能使用一个。但是如果创建了复合索引，这样能够走索引的内容就多了，效率会更高，所以复合索引的使用也很重要，是sql优化的一个很关键的点。 http://tech.meituan.com/mysql-index.html现在只会创建单索引,但是很多情况下,复合索引更有效. 一个表只能使用一个索引,如果单键索引和复合索引都会生效,那么mysql会选择哪个索引。mysql索引的最左选择的原则。 Mysql 优化器。在有很多个索引的情况下，mysql优化器会选择一个比较好的索引。可以利用mysql索引的运算符。索引可用于&lt;、&lt;=、=、&gt;=、&gt; 和BETWEEN运算。在模式具有一个直接量前缀时，索引也用于 LIKE 运算。 有些情况下,优化的作用是很有限的,最好还是不要写太复杂的sql. 但是有一个情景,就是需要更具字表的条件去筛选结果,做分页,这种情况如何处理，可以内存排序.让排序在mysql中排序比较困难.那么这个分页逻辑如何处理. Mysql join之后的索引使用情况是怎么样的，索引可以减少join语句的总共需要扫描的行数，提高join查询的效率。join的时候有个原则就是小标join大表。如果 不会选择，可以不指定join，让mysql自己去选择。order by 的字段是否有必要增加一个索引,如果有必要,是不是所有需要排序的字段都需要增加上索引?这个明显是不可取的。每个query只能利用一个索引,如果where种的字段用到了索引，并且where中的query和order by的字段不是一个，那么只能选择其中的一个索引，所以在一个quer中创建多个单键索引是没有意义的。 索引是在数据库表或者视图上创建的对象，目的是为了加快对表或视图的查询的速度。按照存储方式分为：聚集与非聚集索引; explain 显示mysql如何处理select语句以及连接表,可以帮助写出更好的查询语句和建立更好的索引。rows 表示mysql执行查询的行数,数值越大说明效果越不好,说明没有用好索引.using where :要想使查询尽可能的快, 应尽可能得找出 using filesort , using temporary 的extra的值.我觉这在业务重没有必要禁止连表查询，在不会带来什么压力的情况下，并没有什么必要。如果两个表，都比较简单，连表也没什么不可以。什么事情都应该分开来看待，没有什么是绝对的。 Mysql 复合索引符合索引的表现效率和索引顺序是密切相关的。创建复合索引的时候要仔细考虑顺序。符合索引上是可以增加排序的，查询中的排序必须和索引中的排序一直或者相反才可以用到索引。符合索引引只有一棵树，如果是a,b,c的索引，那么先a，后b，再c，如果a相等，则按照b的顺序排，如果ab都相等，那么按照c的书序排。查找的时候，如果是a，b，c三个都能用到索引的情况，会先按照a确定出一个大概范围，然后在用b来进一步缩小范围，再用c来最后确定查找范围。但是符合索引的顺序怎么设置比较好呢，我觉着这个应该由具体的业务决定。 阻止复合索引使用的情况 范围查找会中断符合索引。 使用计算函数无法使用索引。 &lt;&gt; !=无法使用索引。 CREATE INDEX idx_example ON table1 (col1 ASC, col2 DESC, col3 ASC) Mysql 翻页的方式不要以为翻页只有简单的limit。limit是最简单直接的方法，但是他的缺点也很明显，对于销量数据，千级别的，用这个来翻页取数据还勉强可以，但是如果数据量更大，那么久会很慢。这个时候只能采取其他的方式来设计。所以，对于limit的方式，最好做一个限制数量的翻页，不要做成无限制的翻页。具体参见这个mysql翻页 mysql 中创建用户。CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 如果是当前登陆用户 more detailed info see this link. http://www.jb51.net/article/31850.htm mysql 中的数据类型tinyint 1 字节 -128 ~ 128 smallint 2 字节 -32768 ~ 32767 mediumint 3字节 int 4字节 int(11) bigint 8字节 unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615 Mysql decimal对于精度比较高的东西，比如money，我会用decimal类型，不会考虑float,double,因为他们容易产生误差，numeric和decimal同义，numeric将自动转成decimal。DECIMAL从MySQL 5.1引入，列的声明语法是DECIMAL(M,D)。在MySQL 5.1中，参量的取值范围如下：·M是数字的最大数（精度）。其范围为1～65（在较旧的MySQL版本中，允许的范围是1～254），M 的默认值是10。·D是小数点右侧数字的数目（标度）。其范围是0～30，但不得超过M。说明：float占4个字节，double占8个字节，decimail(M,D)占M+2个字节。 关于decimal范围的判断，下面这是一个不错的解释。 Although the answers above seems correct, just a simple explanation to give you an idea of how it works. Suppose that your column is set to be DECIMAL(13,4). This means that the column will have a total size of 13 digits where 4 of these will be used for precision representation. So, in summary, for that column you would have a max value of: 999999999,9999 引申 为什么floa 和 double 会丢失精度。1 字节 = 8 bit。 int 一般认为是32位。最长是10位。float 为4byte。double 为8btye。IEEE 754 标准，数的存法。 datetime 和 timestamp 的区别。ctime datetime =&gt; now() 4字节 mtime timestamp ==&gt; CURRENT_TIMESTAMP 8字节 1970 ~ 2037 alter table user add column mtime timestamp not null default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP; alter table user add column ctime timestamp not null default CURRENT_TIMESTAMP; 1970 1.1 00:00:00 标准时间，一般情况，mysql需要2个字段，一个是ctime，一个是mtime，mysql中这两个字段一般都是not null 的，timestamp如果是2个默认值都是CURRENT_TIMESTAMP的话，sql会报错，可以像上面那样写。 Mysql 索引操作 mysqldump 数据导出和数据恢复create index index_name on table_name (column_list);alter table table_name add index index_name (column_list);对应的，删除索引。drop index index_name on table;alter table table_name drop index index_name;清空表中的数据，包括 auto_increment 的字段都会被重置。truncate table_name;mysqldump -h localhost -ppasswd -uroot -d database &gt; dump.sql ; // 只导出数据库的结构mysqldump -h localhost -ppasswd -uroot database &gt; dump.sql ; // 导出数据库的结构和所有的数据mysqldump -h localhost -ppasswd -uroot -d database tablename &gt; dump.sql ; // 只导出表结构mysqldump -h localhost -ppasswd -uroot database tablename &gt; dump.sql ; // 导出表结构和表中的数据mysql -u root -p yourpasswd -h localhost yourdb &lt; dump.sql // 将dump.sql 导出入到你的数据库 mysql 中的test 表的使用方法。如果你在数据表中没有数据的到处权限，但是一般的数据库中，test库中的权限你都是有的，所有可以将需要的数据先导入到test中的临时表中，然后再从临时表中导出去。这样可以绕开权限控制，到处你需要的数据。sql如下create table xxx as select * from you_target_table where xxx=xxx;这样 一张 test 中的临时表就创建好了，你可以用mysqldump将这个表中的数据导出去。 mysql时间处理函数select date_format(now(),\"%Y-%m-%d %H:%i:%s\") now;select date_sub(now(), interval 10 day) as yesterday; // 请不要吧 day 写成 days ，month , hour 同理。group by 多个字段 从 col_a -&gt; col_b -&gt; col_c 优先级依次降低。select * from test_table where status = 1 order by col_a desc, col_b desc, col_c asc limit 100;set @a = 100;select @a:=300; #可以通过 select 给变量赋值,这个变量只在这个链接周期中有效。 mysql 存储过程下面是一个简单的存储过程的例子。 delimiter $ # 因为 mysql 默认的 终止符是; 而这个正好是存储过程的语法，所以在编写存储过程之前，先将 delimiter 改成 $create procedure p() # 创建存储过程beginselect * from ttt;end;$delimiter ; # 将 delimiter 改成默认的; 这样符合我们的习惯call p(); # 调用这个存储过程","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.nofile.cc/tags/mysql/"},{"name":"存储","slug":"存储","permalink":"https://blog.nofile.cc/tags/存储/"}],"keywords":[]},{"title":"mysql enable emoj","slug":"note-mysql-emoj","date":"2016-08-24T02:47:00.000Z","updated":"2016-10-09T07:23:14.000Z","comments":true,"path":"posts/2016/08/24/note-mysql-emoj.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/24/note-mysql-emoj.html","excerpt":"","text":"Laravel Mysql 支持emoj1 确保mysql-server是5.5.4+utf8mb4的最低mysql版本支持版本为5.5.3+，若不是，请升级到较新版本。用mysql客户端连接进去，最上面会提示你当前的mysql的版本，确保是5.5.3以上的就可以了。 2 修改database、table和column字符集参考以下语句： ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE table_name modify column_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 3 修改mysql配置文件my.cnfmy.cnf一般在etc/mysql/my.cnf位置。找到后请在以下三部分里添加如下内容： [client]default-character-set = utf8mb4 [mysql]default-character-set = utf8mb4 [mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ciinit_connect=’SET NAMES utf8mb4’ 4. 重启mysql-serverubuntu 的话可以 sudo service mysql restart进入mysql看一下以下变量。 SHOW VARIABLES WHERE Variable_name LIKE &apos;character_set_%&apos; OR Variable_name LIKE &apos;collation%&apos;; +————————–+——————–+| Variable_name | Value |+————————–+——————–+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || collation_connection | utf8mb4_unicode_ci || collation_database | utf8mb4_unicode_ci || collation_server | utf8mb4_unicode_ci |+————————–+——————–+ 5. 设置laravel 的配置。app/config/database.php 中的 mysql 部分的 charset 部分改成 utf8mb4 , collation 改成 ‘utf8mb4_unicode_ci’'charset' =&gt; 'utf8mb4','collation' =&gt; 'utf8mb4_unicode_ci', 上面这些之后，重新尝试以下保存emoj，应该就可以成功了。","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://blog.nofile.cc/tags/laravel/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.nofile.cc/tags/mysql/"},{"name":"emoj","slug":"emoj","permalink":"https://blog.nofile.cc/tags/emoj/"}],"keywords":[]},{"title":"MAC 使用心得","slug":"note-mac","date":"2016-08-23T06:40:00.000Z","updated":"2016-10-09T07:23:12.000Z","comments":true,"path":"posts/2016/08/23/note-mac.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/23/note-mac.html","excerpt":"","text":"MAC 使用心得安装vim 默认情况下，mac terminal中是带了vim 的。但是vim –version 看一下，发现是7.3版本的。这个版本的vim，和mac系统的clipboard交互有点困难。如果想将vim中的内容复制出来的话，会有点麻烦，这又是一个很常用的操作，所以很麻烦。查资料可以知道，7.4的vim可以支持。所以我们通过安装7.4版本的vim来解决这个问题。安装方式如下： brew install vim -clipboard -xterm_clipboard --with-client-server#上面的命令不能成功，出一个很奇怪的错误，所以就没有太纠结。brew install vim --override-system-vim#通过提示可以知道，安装后的vim在下面这这个路径,我们可以通过一个简单的alias搞定。alias v='/usr/local/Cellar/vim/7.4.2152/bin/vim' 然后再试一下，发现不管是terminal中的vim，还是tmux中都可以看到*寄存器了。有了这个寄存器，就说明我们的vim剪切板可以和clipboard之间交互了。 vim backspace不能删除内容的解决方案 可以通过增加配置来解决。 set nocompatibleset backspace=indent,eol,start MAC编译安装php nginx编译的过程中，很可能遇到这个问题。找不到openssl的header files。其实解决办法就是安装openssl。brew install openssl 。 但是只是安装了也可能报这个错误。找到了下面这个帖子。来自 stackoverflow。核心的是这个 brew install opensslbrew link openssl –force 遇到其他的报错，卡主了 confiture ，基本上用brew 安装那个就可以过关了。configure 过了之后，就可以make &amp;&amp; make install 了。 If you are on Mac OS X El Capitan, Apple doesn&apos;t include openssl any more because of security problems openssl had, I have similar problem installing Passenger. brew just installs openssl itself without development headers.If you are on an older version of Mac OS X than El Capitan, you can use: xcode-select --install which installs openssl development headers as well.EDIT:Updating brew and installing openssl and force linking openssl to brew version solved my problem:$ brew update $ which openssl /usr/bin/openssl $ brew install openssl$ brew link openssl --force $ which openssl /usr/local/bin/openssl","categories":[],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.nofile.cc/tags/开发工具/"},{"name":"mac","slug":"mac","permalink":"https://blog.nofile.cc/tags/mac/"}],"keywords":[]},{"title":"Laravel 学习笔记","slug":"note-laravel","date":"2016-08-22T16:41:00.000Z","updated":"2016-10-09T07:23:09.000Z","comments":true,"path":"posts/2016/08/23/note-laravel.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/23/note-laravel.html","excerpt":"","text":"视图在laravel中，controller和view都不可避免的要使用多级目录，controller中使用多级目录的时候，要注意在路由中的写法。在路由中的写法Route::get(&quot;/test&quot;,&#39;Test/TestController@index&#39;),要设置resource，view中的多级目录，在controller中对应的目录结构的写法应该这样的return view(test.test.test)。laravel也用了namespace，这些和其他的框架基本都是一致的。 laravel phphub5时间笔记laravel 的这个错误，可以在这里找到答案。 http://stackoverflow.com/questions/31512970/laravel-no-supported-encrypter-found-the-cipher-and-or-key-length-are-invalid php artisan key:generate 因为用mac,开发环境我是自己配置的,大概包括下面这些内容,nginx(1.9) ， mysql(5.5.3) ， php(5.6) ,redis(3.2) 都是自己装好了的，版本都是比较新的,应该满足需要。还有就是安装composer，之前对这个不怎么了解，但是最近学习laravel，发现这个东西真是太好了，不知道composer只能说明你比较古董，还在几年前的php开发水平上，新技术里没有这个是谈不上高效的，因为好多东西大家都已经写好了，并且都相当稳定了，你再自己去找其他的，就比较没效率了吧,所以composer也是我们的必不可少的。node相关的环境，需要下面这些，node ，npm ，cnpm ,cnpm ,gulp 的安装最好使用alias的那种命令，最好再有nvm，方便安装node。 我本地安装了4.5的node,有了nvm之后，node的版本都是随便选择，随便切换，很方便的。 首先clone phphub5 的官方包。 composer install --prefer-distcnpm install 最好能顺便了解一下package.json , gulp , gulpfile.js这些东西，现在是学习使用，后面可能需要自己开发。cnpm init 可以生成自己的package.json，但是这个只是生成的一个默认的，内容还需要自己扩展进去。通过上面的composer install，安装好了项目依赖的所有的php的扩展包。cnpm install安装好了前端需要的扩展包。这样，项目依赖的内容基本上就ok了，然后配置基本的配置文件。将.env.enviroment 该成 .env 然后将对应的内容修改成自己的db配置。记得打开 config/app.php 的调试信息，这样可以自己方便找出错误。然后在确认下config/database.php 中mysql的配置。和自己本地的db一致就可以了。最后需要修改storage目录的权限，可以 sudo chown www:www -R storage 修改用户组就可以了。改成nginx配置文件中的那个用户组和用户，我的配置里面的是www.www 。通过上面的这些工作，基本上我们的phphub基本上就运行起来了。然后可以根据自己的需求进行定制了。 感觉最近学西最大的收获就是这个项目了，虽然还没有详细研究，但是一个简单的入门，就让我了解到了laravel的高效，之前得开发是效率低并且质量差，并且水平低。这才是正确的做法。当你想做一个产品时，并不是让你从头开始做，你应该对自己所在的领域足够了解，知道有哪些东西已经有了，哪些东西没有，我相信能做好这个判断，会给你的项目节省不少成本，我觉着，这个才是一个技术leader最应该做的事情。","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://blog.nofile.cc/tags/laravel/"}],"keywords":[]},{"title":"382. Linked List Random Node","slug":"ag-382","date":"2016-08-20T11:07:00.000Z","updated":"2016-10-09T07:23:03.000Z","comments":true,"path":"posts/2016/08/20/ag-382.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-382.html","excerpt":"","text":"382. Linked List Random NodeGiven a singly linked list, return a random node&apos;s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 分析这个题目的做法其实很简单。最开始先选择第一个元素，然后一直往后那，到第k个元素，以1/k的概率用这个元素替换已经选中的元素。可以证明每个元素被选中的概率都是1/n。算法最核心就是以1/k的概率替换选中的元素。这个可以利用rand函数就可以实现。因为cnt从0开始，所以拿参0来做参考值。下面是证明过程。第k个元素最终被选择的概率=第k个元素被选择*并且在后面的选择过程中没有被替换的概率=1/k*(1-1/(k+1))*(1-1/(k+2))...*(1-(1/n))=1/n。这就可以表明，算法中的每个元素被选择的概率都是1/n 看了下同类的题解，都说到了这个蓄水池抽样,这篇文章写的不错，里面有详细的分析和证明，大家可以参考下，我就不再这里重复了，最主要的是自己能够计算证明一下概率的计算。 代码import randomclass Solution(object): def __init__(self, head): self.head = head def getRandom(self): tmp = self.head cnt = 0 ans = None while tmp: if random.randint(0,cnt) == 0: ans = tmp tmp = tmp.next cnt += 1 return ans.val class ListNode(object): def __init__(self , val): self.val = val self.next = Nonedef genList(head): prev = head for i in range(0,5): tmp = ListNode(i) tmp.val = i tmp.next = None if i == 0: head = tmp prev = tmp else: prev.next = tmp prev = tmp return headdef printList(head): tmp = head while tmp: print tmp.val, tmp = tmp.next passif __name__=='__main__': head = ListNode(-1) nh = genList(head) mapp = dict() for i in range(0,5): mapp[i] = 0 obj = Solution(nh) for i in range(0,100000): val = obj.getRandom() mapp[val]+=1 for k in mapp: print mapp[k],str(float(mapp[k])/100000 * 100)+\"%\"","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"random","slug":"random","permalink":"https://blog.nofile.cc/tags/random/"}],"keywords":[]},{"title":"Longest Palindromic Substring","slug":"ag-05","date":"2016-08-20T11:06:00.000Z","updated":"2016-10-09T07:22:54.000Z","comments":true,"path":"posts/2016/08/20/ag-05.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-05.html","excerpt":"","text":"Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. 分析看到了将先将原字符串处理成带#的方式，觉着这样处理方便一些。这样处理之后，最长的回文子串一定是关于#中心对称的。所以在我们的算法中，只要对每一个字符j，判断它两边的最长对称串就可以了。整体的复杂度大概是o(n2)。注意对数组越界的处理。这个思路，用python实现了，无奈会超时，该用c实现就可以了。但是刚开始总有几个case和我本机测试不一样。以为oj出问题了，后面再本地多高了几组样例测试，发现本地其实也有问题。后面检查，是我的那个临时变量没有初始化。初始化了之后，ac，并且速度也还可以。作为参考，2份代码都贴了过来，我先写了python版本的，后面发现超时，就将python的翻译成了c版本的。除了char数组变量初始化的坑，其他的基本还好。以后写c代码，一定记得变量初始化。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char* longestPalindrome(char* s) &#123; char ts[2005]; memset(ts,0,sizeof(ts)); ts[0] = '#'; int cnt = 1; for(int i = 0; i &lt; strlen(s); i++)&#123; ts[cnt++] = s[i]; ts[cnt++] = '#'; &#125; int lents = strlen(ts); int max = 1; int pos = 0; for(int i = 0; i &lt;lents; i++)&#123; int currentMax = 1; for(int j = 0 ; j &lt; i ; j++)&#123; int l = i - j - 1; int r = i + j + 1; if(l &lt; 0 || r &gt;= lents)&#123; break; &#125; if( ts[l] == ts[r])&#123; currentMax+=2; &#125;else &#123; break; &#125; &#125; currentMax = (currentMax - 1) / 2; if (currentMax &gt;= max)&#123; max = currentMax; pos = i; &#125; &#125; s = (char *)malloc(2005*sizeof(char)); memset(s , 0 ,sizeof(s)); cnt = 0; for(int i = pos - max + 1; i&lt;pos + max ; i++)&#123; if(ts[i]!='#') s[cnt++] = ts[i]; &#125; s[cnt]='\\0'; return s;&#125;int main()&#123; char str[1000]; while(scanf(\"%s\",str)!=EOF)&#123; char * ans = longestPalindrome(str); printf(\"%s\\n\",ans); &#125; return 0; &#125; class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" ns = \"#\"+\"#\".join(list(s))+\"#\" max = 1 pos = 0 mlen = len(ns) for i in range(0,mlen): currentMax = 1; for j in range(0,i): l = i - j - 1 r = i + 1 + j if l &lt; 0 or r &gt;= mlen: break; if ns[l] == ns[r]: currentMax+=2 else: break; currentMax = (currentMax - 1) /2 if currentMax &gt;= max: max = currentMax pos = i return \"\".join(ns[pos - max: pos + max + 1].split(\"#\")) if __name__=='__main__': ns = Solution() st = \"jglknendplocymmvwtoxvebkekzfdhykknufqdkntnqvgfbahsljkobhbxkvyictzkqjqydczuxjkgecdyhixdttxfqmgksrkyvopwprsgoszftuhawflzjyuyrujrxluhzjvbflxgcovilthvuihzttzithnsqbdxtafxrfrblulsakrahulwthhbjcslceewxfxtavljpimaqqlcbrdgtgjryjytgxljxtravwdlnrrauxplempnbfeusgtqzjtzshwieutxdytlrrqvyemlyzolhbkzhyfyttevqnfvmpqjngcnazmaagwihxrhmcibyfkccyrqwnzlzqeuenhwlzhbxqxerfifzncimwqsfatudjihtumrtjtggzleovihifxufvwqeimbxvzlxwcsknksogsbwwdlwulnetdysvsfkonggeedtshxqkgbhoscjgpiel\" print ns.longestPalindrome(st)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://blog.nofile.cc/tags/string/"}],"keywords":[]},{"title":"Expression Add Operators","slug":"ag-282","date":"2016-08-20T11:06:00.000Z","updated":"2016-10-09T07:23:02.000Z","comments":true,"path":"posts/2016/08/20/ag-282.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/20/ag-282.html","excerpt":"","text":"282. Expression Add OperatorsGiven a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Examples: &quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;] &quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;] &quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;] &quot;3456237490&quot;, 9191 -&gt; [] 分析题目要求找到所有的计算方案。是一个明显的dfs问题。关键是想清楚dfs的方式。dfs的参数大概是这几个。要记录答案retList ，输入参数num，当前的target，当前搜索到字符串内的位置pos，当前的搜索路径path，当前的数字值current，前面的数字值prev。还要注意防止00这样的数字出现，所以在搜索是要对00这样的case进行下清理。 代码class Solution(object): def addOperators(self, num, target): \"\"\" :type num: str :type target: int :rtype: List[str] \"\"\" ans = [] self.solve( num , target , ans , 0 ,\"\" ,0 ,0) return ans def solve(self , num , target , retList , pos , path , current , prev ): if len(num) == pos: if current == target: retList.append(path) return for i in range(pos , len(num)): if i != pos and num[pos] == '0': break; curstr = num[pos:i+1] currentval = int(curstr) if pos == 0: self.solve(num , target , retList , i+1 , path + curstr , current + currentval , currentval) else: self.solve(num , target , retList , i+1 , path + '+' + curstr , current + currentval , currentval) self.solve(num , target , retList , i+1 , path + '-' + curstr , current - currentval , -currentval) self.solve(num , target , retList , i+1 , path + '*' + curstr , current - prev + prev * currentval , prev * currentval)if __name__=='__main__': sn = Solution() num = \"105\" target = 5 print sn.addOperators(num , target)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://blog.nofile.cc/tags/dfs/"}],"keywords":[]},{"title":"HTTPS Your site","slug":"note-https","date":"2016-08-19T08:54:00.000Z","updated":"2016-10-09T07:23:07.000Z","comments":true,"path":"posts/2016/08/19/note-https.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/19/note-https.html","excerpt":"","text":"让NGINX支持SSL需要编译时支持ssl，可以sbin/nginx -V 来查看confiture参数，如果当时没有支持，那么需要重新编译安装。 编译参数前面已经有一篇文章了。nginx编译参数,也不用全加，用--with-http_ssl_module 就可以了。 生成证书主要参考这个letsencrypty，可以生成免费证书。 生成方式也很简单，读上面的文章基本就能明白。ubuntu+nginx. 大致步骤如下： wget https://dl.eff.org/certbot-autochmod a+x certbot-auto./certbot-auto./path/to/certbot-auto certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is 执行完之后系统中会生成这些文件。 This command will obtain a single cert for example.com, www.example.com, thing.is, and m.thing.is; it will place files below /var/www/example to prove control of the first two domains, and under /var/www/thing for the second pair. Automating renewal上面生成的证书，有效期好像是1个月，所以需要到期自己重新renewal一下。方法如下： ./path/to/certbot-auto renew --dry-run./path/to/certbot-auto renew --quiet --no-self-upgrade 配置NGINX配置就不多说了.首先需要配置2个server，监听2个端口。这样可以强制将80端口的请求重定向至443端口。https本身监听的是443端口。最主要的是ssl中间那3行。将步骤2中生成的对应key写在nginx的配置文件里。注意改成你的具体路径。 server &#123; listen 443; server_name blog.nofile.cc; ssl on; ssl_certificate /xxxx/letsencrypt/live/yoursite/fullchain.pem; ssl_certificate_key /xxxx/letsencrypt/live/yoursite/privkey.pem; location / &#123; #这个地方指定被访问的文件夹位置 root /your/webroot/; index index.html; &#125;&#125;server &#123; listen 80; server_name blog.nofile.cc; return 301 https://blog.nofile.cc$request_uri; &#125; 配置好之后，重启nginx，应该就可以看到绿色的锁了。","categories":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}],"tags":[{"name":"https","slug":"https","permalink":"https://blog.nofile.cc/tags/https/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.nofile.cc/tags/nginx/"}],"keywords":[{"name":"web","slug":"web","permalink":"https://blog.nofile.cc/categories/web/"}]},{"title":"String to Integer (atoi)","slug":"ag-08","date":"2016-08-19T03:27:00.000Z","updated":"2016-10-09T07:22:55.000Z","comments":true,"path":"posts/2016/08/19/ag-08.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/19/ag-08.html","excerpt":"","text":"String to Integer (atoi)implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 分析主要还是读题，其实题目还是挺不好读的，有好多细节，读不出来就会wa掉。因为计算过程中32int会溢出，所以结果返回用了long long。不知道用int是不是也可以实现。如果很在意时间的话，题目中应该可以看出，可能包含大量无效字符的case，所以直接忽略这类case，应该可以节省不少时间。 代码#include &lt;stdio.h&gt;int myAtoi(char* str) &#123;#define M_MAX_INT 2147483648#define N_MAX_INT -2147483648 if(str == NULL) return 0; int cnt = 0; int positive_flag = 1; long long ans = 0; while(*str != '\\0')&#123; if(*str == ' ')&#123; if(cnt) break; str++; continue; &#125;else if(*str &gt;= '0' &amp;&amp; *str &lt;='9')&#123; ans = ans * 10 + (*str - '0'); if(ans &gt;= M_MAX_INT ) &#123; if(positive_flag)&#123; ans = 2147483647; &#125;else &#123; ans = N_MAX_INT; &#125; return ans; &#125; cnt++; &#125; else if(*str == '-')&#123; if(cnt) break; positive_flag = 0; cnt++; &#125;else if(*str == '+')&#123; if(cnt) break; cnt++; &#125;else &#123; break; &#125; str++; &#125; if(positive_flag) return ans; else return -1*ans;&#125;int main()&#123; char str[100] =\"\"; while(gets(str))&#123; printf(\"input is: %s\\n\",str); int ans = myAtoi(str); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"atoi","slug":"atoi","permalink":"https://blog.nofile.cc/tags/atoi/"},{"name":"math","slug":"math","permalink":"https://blog.nofile.cc/tags/math/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"}],"keywords":[]},{"title":"leetcode LRU Cache","slug":"ag-146","date":"2016-08-18T15:29:00.000Z","updated":"2016-10-09T07:23:00.000Z","comments":true,"path":"posts/2016/08/18/ag-146.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/18/ag-146.html","excerpt":"","text":"LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析读完题目，其实最核心的部分就是维护一个LRU的顺序，能够在需要淘汰数据的时候以o(1)的算法选出需要淘汰的节点。Python中有有序字典这种数据结构。这种字典可以将字典中的所有(k,v)按照插入顺序来保存。新插入的在后面。并且还提供了popitem方法。正好符合这个题目的要求。popitem(last=True|False),last = False 表示按照FIFO进行pop，True表示按照LIFO进行淘汰。注意边界。插入和访问都需要先将元素从这个OrderedDict中删除，以维护LRU所需要的顺序。 如果没有这种结构的话，可以自己实现一个双向链表来解决这个问题。这样链表结构的调整比较容易，如果是数组的话，将一个元素放在最前面，是要调整整个数组的顺序的，成本太高，这种情况，链表就很有优势,这就是用链表的最重要的原因吧。 代码import collectionsclass LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self.capacity = capacity self.ldict = collections.OrderedDict() def get(self, key): \"\"\" :rtype: int \"\"\" try: value = self.ldict[key] del self.ldict[key] self.ldict[key] = value return value except: return -1 def set(self, key, value): \"\"\" :type key: int :type value: int :rtype: nothing \"\"\" print self.capacity print self.ldict try: del self.ldict[key] self.ldict[key] = value except: if len(self.ldict) == self.capacity: self.ldict.popitem(last=False) self.ldict[key] = value def mprint(self): print self.ldictif __name__=='__main__': lru = LRUCache(3) lru.set(1,1) lru.set(2,2) lru.set(3,3) lru.set(4,4) lru.set(5,5) lru.set(3,3) lru.set(6,6) lru.mprint() pass","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"lru","slug":"lru","permalink":"https://blog.nofile.cc/tags/lru/"},{"name":"ordereddict","slug":"ordereddict","permalink":"https://blog.nofile.cc/tags/ordereddict/"}],"keywords":[]},{"title":"leetcode Mini Parser","slug":"ag-385","date":"2016-08-18T15:03:00.000Z","updated":"2016-10-09T07:23:04.000Z","comments":true,"path":"posts/2016/08/18/ag-385.html","link":"","permalink":"https://blog.nofile.cc/posts/2016/08/18/ag-385.html","excerpt":"","text":"Mini ParserGiven a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty.String does not contain white spaces.String contains only digits 0-9, [, - ,’,’ , ].Example 1: Given s = “324”, You should return a NestedInteger object which contains a single integer 324.Example 2: Given s = “[123,[456,[789]]]”, Return a NestedInteger object containing a nested list with 2 elements: An integer containing value 123. A nested list containing two elements: An integer containing value 456. A nested list with one element: An integer containing value 789. 分析应该是一个字符串处理的问题。对特殊字符进行处理，处理事件主要由[,]来触发。o(n)算法。需要想清楚对每一个字符的处理方式。NestedInteger的维护，会使用到栈这种结构，在Python里面，list可以当作栈来使用。这个题目的边界条件，主要是[]里面可能是空的。整个过程有一点小复杂，主要还是靠自己思考，脑筋动起来吧。示例代码中的NestedInteger的class的方法是我自己加的，为了测试代码，测试语法问题。 代码class NestedInteger(object): def __init__(self,elem=None): pass def add(self , a): passclass Solution(object): def deserialize(self, s): \"\"\" :type s: str :rtype: NestedInteger \"\"\" lst = [] last_ic_ix = 0 if s[0] != '[': return NestedInteger(int(s)) for i in range(0,len(s)): if s[i] == '[': ns = NestedInteger() lst.append(ns) last_ic_ix = i elif s[i] == ',' or s[i] == ']': ss = s[last_ic_ix+1:i] if ss != '': tmp = int(ss) lst[len(lst)-1].add(NestedInteger(tmp)) last_ic_ix = i if s[i] == ']': top = lst.pop() if len(lst) == 0: return top lst[len(lst)-1].add(top) return Falseif __name__=='__main__': ns = Solution() print ns.deserialize(\"[123,3,[32,2,[33,24],3]]\");","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.nofile.cc/tags/leetcode/"},{"name":"stack","slug":"stack","permalink":"https://blog.nofile.cc/tags/stack/"},{"name":"python","slug":"python","permalink":"https://blog.nofile.cc/tags/python/"}],"keywords":[]}]}